<!DOCTYPE html>
<html lang="en">
<head>
    <base target="_top">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Grimoire | v6.1 (Settings & Tags)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü©∏</text></svg>">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- THEME & VARS --- */
        :root { 
            --primary: #a78bfa; 
            --bg-dark: #0f0a1c; 
            --card-bg: rgba(45, 21, 60, 0.8); 
            --text: #f8fafc; 
            --subtext: #a1a1aa; 
            --border: rgba(167, 139, 250, 0.2); 
            --green: #d946ef; --red: #dc2626; --yellow: #facc15; --blue: #3b82f6; 
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            --chart-color-1: #d946ef; --chart-color-2: #dc2626; --chart-color-3: #a78bfa; --chart-color-4: #4f46e5; --chart-color-5: #059669;
        }

        body { font-family: 'Inter', sans-serif; background: radial-gradient(circle at top left, #1a1a1a, var(--bg-dark)); background-attachment: fixed; color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; font-size: clamp(1rem, 0.8rem + 0.5vw, 1.125rem); overflow: hidden; transition: background 0.5s; }
        * { box-sizing: border-box; }
        .hidden { display: none !important; }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; } ::-webkit-scrollbar-thumb:hover { background: var(--primary); }

        /* LOGIN SCREEN AESTHETIC */
        #auth-screen { 
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #000 100%);
            position: relative;
        }
        .auth-box {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            padding: 40px;
            border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 380px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border);
        }
        
        /* Toast Style */
        .toast {
            background: var(--card-bg);
            border: 1px solid var(--primary);
            color: var(--text);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            opacity: 1;
            transition: opacity 0.3s, transform 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        .toast.hiding {
            opacity: 0;
            transform: translateY(20px);
        }
        .toast.error { border-color: var(--red); color: var(--red); }
        .toast.success { border-color: var(--green); color: var(--green); }


        /* --- LAYOUT & NAV --- */
        .app-container { display: grid; grid-template-columns: 240px 1fr; height: 100%; overflow: hidden; }
        .sidebar { background: var(--card-bg); backdrop-filter: blur(12px); border-right: 1px solid var(--border); padding: 25px; display: flex; flex-direction: column; z-index: 10; transition: border-color 0.3s; }
        .bottom-nav { display: none; } 

        /* Mobile Overrides */
        @media (max-width: 768px) { 
            .app-container { 
                grid-template-columns: 1fr; 
                padding-bottom: 80px; 
            } 
            .sidebar { 
                display: none; 
            } 
            .bottom-nav { 
                display: flex; 
                position: fixed; 
                bottom: 0; 
                left: 0; 
                width: 100%; 
                background: rgba(15, 10, 28, 0.95); 
                border-top: 1px solid var(--border); 
                padding: 10px 0; 
                justify-content: space-around; 
                z-index: 20; 
                backdrop-filter: blur(10px); 
            }
            .main {
                padding: 20px 15px; 
            }
            .stat-grid {
                grid-template-columns: repeat(2, 1fr); 
            }
            .dashboard-split {
                grid-template-columns: 1fr; 
            }
            #view-add .card-box, #view-settings .card-box {
                max-width: 100%;
                margin: 0;
            }
        }

        .logo { font-size: 22px; font-weight: 700; color: var(--primary); margin-bottom: 40px; display: flex; align-items: center; gap: 12px; transition: color 0.3s; }
        .nav-item { padding: 12px 15px; cursor: pointer; color: var(--subtext); font-weight: 500; border-radius: 8px; transition: all 0.2s; margin-bottom: 4px; display: flex; align-items: center; gap: 10px; }
        .nav-item:hover { background: rgba(255, 255, 255, 0.05); color: white; }
        .nav-item.active { background: rgba(255, 255, 255, 0.1); color: white; border-left: 3px solid var(--primary); padding-left: 12px; }
        .main { padding: 40px clamp(1rem, 2vw + 1rem, 5rem); overflow-y: auto; flex: 1; -webkit-overflow-scrolling: touch; }
        #view-battlefield { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 50; background: var(--bg-dark); overflow: hidden; display: flex; flex-direction: column; }
        .b-item { display: flex; flex-direction: column; align-items: center; font-size: 10px; color: var(--subtext); cursor: pointer; }
        .b-icon { font-size: 20px; margin-bottom: 4px; }
        .b-item.active { color: var(--primary); }

        /* --- COMPONENTS --- */
        .skeleton {
            background-color: var(--card-bg);
            background-image: linear-gradient(90deg, 
                var(--card-bg) 0%, 
                rgba(167, 139, 250, 0.1) 20%, 
                var(--card-bg) 40%, 
                var(--card-bg) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite linear;
            border-radius: 4px;
        }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .skeleton-text { height: 1em; width: 100%; margin-bottom: 0.5em; }
        .skeleton-text-small { height: 0.7em; width: 60%; margin: 0 auto 0.5em; }
        .skeleton-avatar { width: 50px; height: 50px; border-radius: 50%; }

        .card-box { background: var(--card-bg); backdrop-filter: blur(12px); padding: 1.5rem; border-radius: 16px; border: 1px solid var(--border); margin-bottom: 24px; box-shadow: var(--shadow); transition: border-color 0.3s; }
        h2 { margin-top: 0; font-size: 1.5rem; font-weight: 600; margin-bottom: 20px; }
        h3 { font-size: 1rem; font-weight: 600; color: var(--subtext); margin-top: 0; text-transform: uppercase; font-size: 12px; margin-bottom: 15px;}
        .input-group { position: relative; display: flex; align-items: center; margin-bottom: 15px; }
        .input-icon { position: absolute; left: 12px; color: var(--subtext); font-size: 16px; pointer-events: none; }
        input, select { width: 100%; padding: 14px 14px 14px 40px; border-radius: 8px; border: 1px solid var(--border); background: rgba(0,0,0,0.4); color: white; font-size: 14px; margin: 0; }
        textarea { padding: 14px; margin-bottom: 15px; height: 350px; resize: vertical; background: rgba(0,0,0,0.2); border: 1px solid var(--border); color: var(--text); border-radius: 8px; width: 100%; font-family: monospace; font-size: 13px; }
        button { width: 100%; padding: 14px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; transition: transform 0.1s, opacity 0.2s, background 0.3s; }
        button:hover { opacity: 0.85; } button:active { transform: scale(0.98); }
        button.secondary { background: rgba(255,255,255,0.1); }
        .clear-btn { background: none; color: var(--subtext); width: 40px; padding: 0; height: 100%; margin-left: 10px; opacity: 0.7; }
        
        /* THEME PICKER */
        .theme-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin-bottom: 20px; }
        .theme-btn { width: 100%; aspect-ratio: 1; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: transform 0.2s; }
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.active-theme { border-color: white; box-shadow: 0 0 10px white; }

        /* DASHBOARD & AVATAR */
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: rgba(255,255,255,0.03); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,255,255,0.1); }
        .stat-val { font-size: 28px; font-weight: 700; color: white; margin-bottom: 5px; }
        .stat-lbl { font-size: 11px; text-transform: uppercase; color: var(--subtext); font-weight: 600; letter-spacing: 1px; }
        .dashboard-split { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .asset-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .asset-info { display: flex; align-items: center; gap: 15px; }
        .asset-img { width: 40px; height: 56px; border-radius: 4px; object-fit: cover; border: 1px solid var(--border); }
        .asset-val { font-weight: 700; color: var(--green); }
        
        .user-profile-section { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border); }
        .avatar-circle { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; border: 2px solid var(--primary); background: rgba(0,0,0,0.2); }
        .user-meta { display: flex; flex-direction: column; overflow: hidden; }
        .user-name { font-weight: 700; color: white; font-size: 14px; }
        .user-email-txt { font-size: 11px; color: var(--subtext); overflow: hidden; text-overflow: ellipsis; }
        .avatar-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; max-height: 400px; overflow-y: auto; margin-top: 15px; }
        .avatar-option { width: 100%; border-radius: 6px; cursor: pointer; border: 2px solid transparent; transition: transform 0.2s; }
        .avatar-option:hover { transform: scale(1.05); border-color: var(--primary); }

        /* GRIDS & CARDS */
        .collection-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 20px; }
        #recent-grid { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; }
        .grid-card { position: relative; aspect-ratio: 2.5/3.5; border-radius: 10px; overflow: hidden; cursor: pointer; transition: transform 0.2s; background: rgba(0,0,0,0.3); border: 1px solid var(--border); }
        .grid-card:hover { transform: translateY(-5px); border-color: var(--primary); }
        .grid-card img { width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.5s; }
        .overlay { position: absolute; bottom: 0; width: 100%; padding: 10px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); font-size: 12px; font-weight: 600; color: white; display:flex; justify-content:space-between; align-items: flex-end; box-sizing: border-box; height: 50px; }
        .gain-badge { position: absolute; top: 10px; right: 10px; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700; background: rgba(0,0,0,0.8); z-index: 5; }
        .tag-container { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 5; align-items: flex-start; }
        .tag-pill { background: var(--primary); color: white; font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 700; box-shadow: 0 2px 5px rgba(0,0,0,0.5); white-space: nowrap; max-width: 100px; overflow: hidden; text-overflow: ellipsis; }

        /* LIST VIEW */
        .vault-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .vault-table th { text-align: left; padding: 12px; color: var(--subtext); border-bottom: 1px solid var(--border); font-weight: 600; text-transform: uppercase; font-size: 11px; }
        .vault-table td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); vertical-align: middle; }
        .vault-table tr:hover { background: rgba(255,255,255,0.03); }
        .list-img { width: 30px; height: 42px; border-radius: 4px; object-fit: cover; }
        .view-toggle { display: flex; background: rgba(0,0,0,0.3); border-radius: 6px; padding: 2px; border: 1px solid var(--border); }
        .view-btn { padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; color: var(--subtext); font-weight: 600; }
        .view-btn.active { background: var(--primary); color: white; }
        
        #hover-preview { position: fixed; pointer-events: none; z-index: 9999; width: 220px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); border: 2px solid var(--primary); display: none; transform: translateY(-50%); animation: fadeIn 0.1s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-40%); } to { opacity: 1; transform: translateY(-50%); } }

        /* DECK WORKSPACE */
        .deck-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 20px; }
        .deck-card { 
            background: rgba(255,255,255,0.05); border: 1px solid var(--border); border-radius: 12px; 
            height: 300px; display: flex; flex-direction: column; justify-content: flex-end; 
            position: relative; overflow: hidden; cursor: pointer; transition: all 0.3s;
            background-size: cover; background-position: center;
        }
        .deck-card:hover { border-color: var(--primary); transform: translateY(-5px); box-shadow: var(--shadow); }
        .deck-card::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to top, rgba(15, 10, 28, 1) 0%, rgba(15, 10, 28, 0.6) 40%, rgba(15, 10, 28, 0) 100%);
            z-index: 1;
        }
        .deck-card-content { position: relative; z-index: 2; padding: 20px; }
        .deck-card h4 { margin: 0; color: white; font-size: 18px; text-shadow: 0 2px 4px black; margin-bottom: 5px; }
        .deck-card-meta { color: var(--subtext); font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
        .format-badge { background: var(--primary); color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; }
        .new-deck-card { border: 1px dashed var(--subtext); display: flex; align-items: center; justify-content: center; flex-direction: column; color: var(--subtext); background: none; }
        .new-deck-card:hover { border-color: var(--primary); color: var(--primary); background: rgba(255,255,255,0.02); }
        .new-deck-card::after { display: none; }
        
        .deck-area-edit { display: block; } 
        .deck-area-detail { display: grid; grid-template-columns: 1fr 400px; gap: 20px; }
        .deck-list-viewer { height: 70vh; overflow-y: auto; white-space: pre-wrap; padding: 15px; font-size: 14px; line-height: 1.5; color: var(--text); background: rgba(0,0,0,0.1); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); }
        .editor-header { display: flex; gap: 10px; margin-bottom: 20px; background: rgba(255,255,255,0.03); padding: 15px; border-radius: 8px; border: 1px solid var(--border); align-items: center; }
        .editor-split { display: grid; grid-template-columns: 3fr 1fr; gap: 20px; height: 60vh; }
        .editor-column { display: flex; flex-direction: column; }
        .editor-label { color: var(--subtext); font-size: 12px; text-transform: uppercase; margin-bottom: 8px; font-weight: 600; display: flex; justify-content: space-between; }
        
        /* VISUAL DECK GRID */
        .visual-grid-container { height: 70vh; overflow-y: auto; padding-right: 5px; }
        .visual-section { margin-bottom: 20px; }
        .visual-header { font-size: 12px; text-transform: uppercase; color: var(--subtext); border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 10px; padding-bottom: 5px; font-weight: 700; }
        .visual-card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; }
        .visual-card { position: relative; border-radius: 6px; overflow: hidden; transition: transform 0.2s; cursor: pointer; aspect-ratio: 2.5/3.5; }
        .visual-card:hover { transform: scale(1.05); z-index: 10; border: 1px solid var(--primary); }
        .visual-card img { width: 100%; height: 100%; object-fit: cover; }
        .visual-badge { position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.8); color: white; font-size: 10px; padding: 2px 6px; border-top-left-radius: 6px; font-weight: 700; }
        .cover-btn { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.8); color: rgba(255,255,255,0.7); border: none; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0.7; transition: opacity 0.2s; z-index: 20; font-size: 14px; }
        .cover-btn:hover { background: var(--yellow); color: black; opacity: 1; transform: scale(1.1); }
        .is-cover-card .cover-btn { opacity: 1; color: var(--yellow); background: black; }

        #deck-charts { display: flex; flex-direction: column; gap: 20px; padding-top: 20px; }
        #saved-decks-list { max-height: 450px; overflow-y: auto; padding-right: 5px; display: flex; flex-direction: column; gap: 10px; }
        .deck-item-preview { background: rgba(255,255,255,0.05); padding:15px; border-radius:8px; border:1px solid var(--border); cursor:pointer; display:flex; justify-content:space-between; align-items:center; position: relative; }
        .deck-item-preview:hover { border-color: var(--primary); }
        .deck-item-info { font-size: 12px; color: var(--subtext); font-weight: 400; margin-top: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* THE LINK */
        .deck-line { padding: 4px 8px; border-radius: 4px; margin-bottom: 2px; }
        .is-owned { color: var(--green); border-left: 2px solid var(--green); background: rgba(217, 70, 239, 0.05); }
        .is-partial { color: var(--yellow); border-left: 2px solid var(--yellow); background: rgba(250, 204, 21, 0.05); }
        .is-missing { color: var(--red); border-left: 2px solid var(--red); opacity: 0.8; }
        .progress-bg { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; margin-top: 5px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); transition: width 0.5s ease-out; }

        /* BATTLEFIELD 2.0 */
        .bf-hud { height: 60px; background: rgba(0,0,0,0.8); border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 100; }
        .bf-stat { font-size: 14px; font-weight: 700; display: flex; gap: 10px; align-items: center; }
        .bf-main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; background: radial-gradient(circle at center, #2d153c 0%, #0f0a1c 70%); }
        .bf-field { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 10px; }
        .bf-hand-area { height: 220px; background: rgba(0,0,0,0.85); border-top: 1px solid var(--border); padding: 15px 20px; display: flex; gap: 20px; overflow-x: auto; align-items: center; }
        .bf-card { width: 120px; border-radius: 8px; cursor: pointer; transition: transform 0.1s, box-shadow 0.2s; position: relative; flex-shrink: 0; }
        .bf-card img { width: 100%; border-radius: 8px; }
        .bf-card:hover { transform: translateY(-10px); z-index: 10; box-shadow: 0 0 15px var(--primary); }
        .bf-tapped { transform: rotate(5deg) translateY(10px); opacity: 0.6; filter: grayscale(50%); }
        .bf-zone-btn { width: 100px; height: 140px; border: 1px dashed var(--subtext); border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--subtext); cursor: pointer; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; text-align: center; }
        .bf-zone-btn:hover { border-color: var(--primary); color: white; background: rgba(255,255,255,0.05); }
        .bf-row { flex: 1; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 10px; padding: 20px; border-bottom: 1px dashed rgba(255,255,255,0.1); overflow-y: auto; transition: background 0.2s; }
        .bf-row:last-child { border-bottom: none; background: rgba(0,0,0,0.2); }
        .bf-row-label { width: 100%; font-size: 10px; color: var(--subtext); text-transform: uppercase; margin-bottom: 5px; opacity: 0.5; pointer-events: none; }
        .tap-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white; text-shadow: 0 0 10px black; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .bf-tapped .tap-icon { opacity: 1; }
        .counter-badge { position: absolute; top: -5px; right: -5px; background: var(--red); color: white; border-radius: 50%; width: 24px; height: 24px; font-size: 11px; font-weight: 700; display: flex; align-items: center; justify-content: center; border: 2px solid #0f0a1c; z-index: 20; box-shadow: 0 2px 5px black; }
        .token-card { background: #1e1e1e; border: 2px dashed var(--subtext); display: flex; align-items: center; justify-content: center; color: white; font-weight: 700; text-align: center; font-size: 12px; }

        /* LAND CALCULATOR MODAL */
        .mana-row { display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid rgba(255,255,255,0.05); align-items: center; }
        .mana-pip { width:20px; height:20px; border-radius:50%; display:inline-block; margin-right:8px; vertical-align:middle; text-align: center; line-height: 20px; font-size: 12px; color:black; font-weight:700; }
        .pip-w { background:#f0f2c0; } .pip-u { background:#b3ceea; } .pip-b { background:#a69f9d; } .pip-r { background:#ea9f82; } .pip-g { background:#c4d3ca; }

        /* MODALS FIX V3.5.1 */
        .modal-overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(15, 10, 28, 0.95); 
            z-index: 1000; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            overflow-y: auto;
            padding: 20px;
            backdrop-filter: blur(10px); 
        }
        .modal-content { 
            width: 90%; 
            max-width: 800px; 
            text-align: center; 
            flex-shrink: 0;
        }
    </style>
</head>
<body>

    <img id="hover-preview"> 

    <div id="toast-container" style="position: fixed; bottom: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px;"></div>

    <div id="report-modal" class="modal-overlay hidden">
        <div class="modal-content card-box" style="max-width: 400px;">
            <h2 style="color:var(--red);">ü™≤ Submit Bug Report</h2>
            <p style="color:var(--subtext);">Tell us what broke, and we will crush the insect.</p>
            <textarea id="bug-description" placeholder="Steps to reproduce, expected behavior, and actual behavior." style="height: 200px; margin-bottom: 20px;"></textarea>
            <div style="display:flex; gap:10px; justify-content: center;">
                <button onclick="reportBug()" style="background:var(--red);">üêõ Send Report</button>
                <button onclick="document.getElementById('report-modal').classList.add('hidden')" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="land-modal" class="modal-overlay hidden">
        <div class="modal-content card-box" style="max-width: 400px;">
            <h2 style="color:var(--primary);">The Geomancer</h2>
            <p style="color:var(--subtext);">Recommended basic land balance based on your spell symbols.</p>
            <div style="margin-bottom:20px; text-align:left;">
                <label style="font-size:12px; color:var(--subtext);">Target Land Count</label>
                <input type="number" id="target-land-count" value="24" onchange="recalcLands()" style="margin-top:5px;">
            </div>
            <div id="land-results" style="margin-bottom:20px;"></div>
            <div style="display:flex; gap:10px; justify-content: center;">
                <button onclick="applyLands()" style="background:var(--green);">üíæ Add to Deck</button>
                <button onclick="document.getElementById('land-modal').classList.add('hidden')" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="avatar-modal" class="modal-overlay hidden">
        <div class="modal-content card-box">
            <h2 style="color:var(--primary);">Choose Your Avatar</h2>
            <p style="color:var(--subtext);">Select a card from your Collection to represent you.</p>
            <div id="avatar-grid" class="avatar-grid"></div>
            <button onclick="document.getElementById('avatar-modal').classList.add('hidden')" class="secondary" style="margin-top:20px; width:auto;">Cancel</button>
        </div>
    </div>

    <div id="user-options-modal" class="modal-overlay hidden" onclick="closeUserOptionsModal()">
        <div class="modal-content card-box" style="max-width: 300px; text-align: left;" onclick="event.stopPropagation()">
            <h2 style="color:var(--primary); margin-bottom: 15px;">Account Actions</h2>
            <button class="secondary" onclick="nav('settings', 'settings'); closeUserOptionsModal()" style="margin-bottom: 10px; padding: 12px; border: 1px solid var(--border); color: var(--subtext); width: 100%;">‚öôÔ∏è View Settings</button>
            <button onclick="openAvatarModal(); closeUserOptionsModal()" style="margin-bottom: 10px; padding: 12px; background: rgba(255, 255, 255, 0.1); color: white; width: 100%;">üñºÔ∏è Change Avatar</button>
            <button onclick="handleLogout()" style="background:var(--red); width: 100%;">üö™ Break Pact (Log Out)</button>
        </div>
    </div>

    <div id="bulk-modal" class="modal-overlay hidden">
        <div class="modal-content card-box">
            <h2 style="color:var(--primary);">The Scribe (Bulk Import)</h2>
            <p style="color:var(--subtext); margin-bottom: 20px;">Paste a list of cards to bind them all at once.<br>Format: <code>Quantity Name</code> (e.g., "4 Sol Ring")</p>
            <textarea id="bulkList" placeholder="4 Sol Ring&#10;10 Mountain&#10;1 The One Ring" style="height: 300px;"></textarea>
            <div style="display: flex; gap: 20px; justify-content: center; margin-top: 20px;"><button onclick="processBulkImport()" style="background: var(--green);">üìú Inscribe to Collection</button><button onclick="closeBulkModal()" class="secondary">Cancel</button></div>
            <div id="bulk-status" style="margin-top:15px; font-size:13px; color:var(--subtext);"></div>
        </div>
    </div>

    <div id="delete-modal" class="modal-overlay hidden">
        <div class="modal-content card-box" style="max-width: 400px; border-color: var(--red);">
            <h2 style="color:var(--red);">Sacrifice Decklist?</h2>
            <p style="color:var(--subtext); margin-bottom:20px;">Are you sure you want to destroy <b id="delete-target-name" style="color:white;">this decklist</b>?<br>This action cannot be undone.</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="confirmDelete()" style="background:var(--red);">üî• Destroy</button>
                <button onclick="closeDeleteModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="edit-modal" class="modal-overlay hidden">
        <div class="modal-content card-box" style="max-width: 400px;">
            <h2 style="color:var(--primary);" id="edit-card-name">Edit Card</h2>
            <input type="hidden" id="edit-card-id">
            <div style="text-align:left; margin-bottom:10px;"><label style="font-size:12px; color:var(--subtext);">Quantity (Set 0 for Wishlist)</label><input type="number" id="edit-qty" style="margin-top:5px;"></div>
            <div style="text-align:left; margin-bottom:20px;"><label style="font-size:12px; color:var(--subtext);">Cost Basis (Per Card)</label><div class="input-group" style="margin-top:5px;"><span class="input-icon">üí∞</span><input type="number" id="edit-cost" step="0.01" style="padding-left:40px;"></div></div>
            <div style="text-align:left; margin-bottom:20px;"><label style="font-size:12px; color:var(--subtext);">Tags (comma separated)</label><div class="input-group" style="margin-top:5px;"><span class="input-icon">üè∑Ô∏è</span><input type="text" id="edit-tags" placeholder="Foil, Trade, Damaged..." style="padding-left:40px;"></div></div>
            <div style="display: flex; gap: 20px; justify-content: center;"><button onclick="saveEdit()" style="background: var(--green);">üíæ Save Changes</button><button onclick="document.getElementById('edit-modal').classList.add('hidden')" class="secondary">Cancel</button></div>
        </div>
    </div>

    <div id="codex-modal" class="modal-overlay hidden">
        <div class="modal-content card-box" style="max-width: 800px;">
            <div id="codex-loading" style="padding: 40px; color: var(--subtext);">Consulting the archives...</div>
            <div id="codex-content" class="codex-layout hidden">
                <div><img id="codex-img" class="codex-img" src=""></div>
                <div class="codex-info">
                    <div id="codex-title" class="codex-title">Card Name</div>
                    <div id="codex-type" class="codex-type">Type Line</div>
                    <div id="codex-text" class="codex-text">Oracle text goes here...</div>
                    <h4 style="margin:0; font-size:12px; color:var(--subtext); text-transform:uppercase;">Format Legality</h4>
                    <div id="codex-legality" class="legality-grid"></div>
                    <div style="margin-top:20px; display:flex; gap:10px;"><button class="secondary" onclick="document.getElementById('codex-modal').classList.add('hidden')">Close Codex</button><button onclick="window.open(window.scryfallLink, '_blank')" style="width:auto; background:#2b253a;">View on Scryfall ‚Üó</button></div>
                </div>
            </div>
        </div>
    </div>

    <div id="prophecy-modal" class="modal-overlay hidden">
        <div class="prophecy-content">
            <h2 style="color:var(--primary); text-shadow: 0 0 10px var(--primary); margin-bottom: 10px;">üîÆ The Prophecy</h2>
            <p style="color:var(--subtext); margin-bottom: 20px;">Divining a starting hand from the ether...</p>
            <div class="prophecy-hand" id="prophecy-hand-container"></div>
            <div style="display: flex; gap: 20px; justify-content: center;"><button onclick="drawProphecy()" class="secondary" style="width: auto; padding: 12px 30px; background: var(--primary);">üîÑ Mulligan</button><button onclick="closeProphecy()" class="secondary" style="width: auto; padding: 12px 30px;">Close Vision</button></div>
        </div>
    </div>

    <div id="auth-screen">
        <div class="auth-box">
            <div style="font-size:50px; margin-bottom:15px; text-shadow: 0 0 15px var(--primary);">ü©∏</div>
            <h2 style="margin:0 0 10px 0; color:white;">The Grimoire</h2>
            <p style="color:var(--subtext); margin-bottom:25px; font-size:14px;">Unleash your collection's true power.</p>
            <div class="input-group"><input type="email" id="email" placeholder="Sacrificial Email" style="padding-left: 14px;"></div>
            <div class="input-group"><input type="password" id="password" placeholder="Runic Key" style="padding-left: 14px;"></div>
            <button onclick="handleAuthAction()" id="auth-btn">Summon Session</button>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:15px; font-size:12px;">
                <div style="text-align: left; max-width: 60%;">
                    <span id="auth-msg" style="color:var(--subtext); display:block;">First time? A pact will be forged upon login.</span>
                    <a href="privacy.html" target="_blank" style="color:var(--subtext); opacity: 0.6; text-decoration: underline; margin-top: 4px; display: inline-block;">Privacy Policy</a>
                </div>
                <span id="forgot-link" style="color:var(--primary); cursor:pointer; font-weight:600;" onclick="toggleResetMode()">Forgot Password?</span>
            </div>
        </div>
    </div>

    <div id="app" class="app-container hidden">
        <div class="sidebar">
            <div class="logo"><span>ü©∏</span> The Grimoire</div>
            <div class="user-profile-section">
                <img id="sidebar-avatar" class="avatar-circle" src="https://svgshare.com/i/10gq.svg">
                <div class="user-meta">
                    <div id="sidebar-username" class="user-name">Wizard</div>
                    <div id="user-email" class="user-email-txt">Loading...</div>
                </div>
            </div>
            
            <div class="nav-item active" onclick="nav('dashboard', 'dashboard')">üè† Dashboard</div>
            <div class="nav-item" onclick="nav('add', 'add')">‚ûï Add Card</div>
            <div class="nav-item" onclick="nav('collection', 'collection')">üìö Collection</div>
            <div class="nav-item" onclick="nav('oracle', 'oracle')">üëÅÔ∏è Wishlist</div>
            <div class="nav-item" onclick="nav('decks', 'decks')">üìã Decklists</div>
            <div class="nav-item" onclick="nav('settings', 'settings')">‚öôÔ∏è Settings</div>
            <div style="flex-grow:1;"></div>
            
            <button class="secondary" style="margin-bottom: 10px; background: rgba(220, 38, 38, 0.1); color: var(--red); border: 1px solid var(--red);" onclick="document.getElementById('report-modal').classList.remove('hidden')">ü™≤ Report Bug</button>

            <div style="padding:15px 0; border-top:1px solid var(--border); margin-top:10px;">
                <div style="font-size: 10px; color: var(--subtext); margin-bottom: 5px;">v6.1</div>
                <button class="secondary" onclick="openUserOptionsModal()">üßô Profile & Logout</button>
            </div>
        </div>

        <div class="main">
            <div id="view-dashboard">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:30px;"><h2 style="margin:0;">Dashboard</h2><button class="secondary" style="width:auto; padding:8px 16px; font-size:12px;" onclick="exportCSV()">üìâ Export Data (CSV)</button></div>
                <div class="stat-grid">
                    <div class="stat-card"><div class="stat-val skeleton" id="stat-count" style="height:28px; width:50%; margin:0 auto 5px;"></div><div class="stat-lbl">Cards Owned</div></div>
                    <div class="stat-card"><div class="stat-val skeleton" id="stat-value" style="height:28px; width:70%; margin:0 auto 5px;"></div><div class="stat-lbl">Portfolio Value</div></div>
                    <div class="stat-card"><div class="stat-val skeleton" id="stat-cost" style="height:28px; width:70%; margin:0 auto 5px;"></div><div class="stat-lbl">Total Investment</div></div>
                    <div class="stat-card"><div class="stat-val skeleton" id="stat-oracle" style="height:28px; width:70%; margin:0 auto 5px;"></div><div class="stat-lbl">Wishlist Cost</div></div>
                    <div class="stat-card"><div class="stat-val skeleton" id="stat-gain" style="height:28px; width:70%; margin:0 auto 5px;"></div><div class="stat-lbl">Gain/Loss (Market)</div></div>
                </div>
                <div class="dashboard-split">
                    <div class="card-box"><h3>üèÜ Top 5 High-Value Assets</h3><div id="top-assets-list">
                        <div class="asset-row"><div class="asset-info"><div class="skeleton" style="width:40px; height:56px; border-radius:4px;"></div><div style="width:60%;"><div class="skeleton-text skeleton" style="height:14px; width:90%;"></div><div class="skeleton-text skeleton" style="height:11px; width:70%; margin-top:5px;"></div></div></div><div class="skeleton-text skeleton" style="width:50px; height:18px;"></div></div>
                        <div class="asset-row"><div class="asset-info"><div class="skeleton" style="width:40px; height:56px; border-radius:4px;"></div><div style="width:60%;"><div class="skeleton-text skeleton" style="height:14px; width:90%;"></div><div class="skeleton-text skeleton" style="height:11px; width:70%; margin-top:5px;"></div></div></div><div class="skeleton-text skeleton" style="width:50px; height:18px;"></div></div>
                    </div></div>
                    <div class="card-box"><h3>Recent Acquisitions</h3><div class="collection-grid" id="recent-grid">
                        <div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div>
                    </div></div>
                </div>
            </div>

            <div id="view-settings" class="hidden">
                <div class="card-box" style="max-width: 500px; margin: 0 auto;">
                    <h2>üßô‚Äç‚ôÇÔ∏è Wizard Identity</h2>
                    <div style="text-align:center; margin-bottom:20px;">
                        <img id="settings-avatar" class="avatar-circle" style="width:100px; height:100px; margin-bottom:15px;" src="https://svgshare.com/i/10gq.svg">
                        <br>
                        <button onclick="openAvatarModal()" class="secondary" style="width:auto;">Change Avatar from Collection</button>
                    </div>
                    
                    <div class="input-group"><span class="input-icon">üë§</span><input type="text" id="settings-username" placeholder="Display Name (e.g. Jace Beleren)"></div>
                    <button onclick="saveProfile()" style="margin-bottom:30px; background:var(--green);">üíæ Save Identity</button>
                    
                    <h3 style="border-top:1px solid var(--border); padding-top:20px;">üé® Grimoire Theme</h3>
                    <div class="theme-grid">
                        <div class="theme-btn" style="background:#a78bfa;" onclick="applyTheme('purple')" title="Arcane (Default)"></div> 
                        <div class="theme-btn" style="background:#fcd34d;" onclick="applyTheme('white')" title="White"></div> 
                        <div class="theme-btn" style="background:#60a5fa;" onclick="applyTheme('blue')" title="Blue"></div> 
                        <div class="theme-btn" style="background:#18181b; border-color:#52525b;" onclick="applyTheme('black')" title="Black"></div> 
                        <div class="theme-btn" style="background:#f87171;" onclick="applyTheme('red')" title="Red"></div> 
                        <div class="theme-btn" style="background:#34d399;" onclick="applyTheme('green')" title="Green"></div> 
                    </div>

                    <h3 style="border-top:1px solid var(--border); padding-top:20px;">üíµ Default Price Source</h3>
                    <div class="input-group" style="padding-left: 0; margin-bottom: 30px;">
                        <span class="input-icon">üí∞</span>
                        <select id="settingsPriceSource" style="padding-left: 40px; margin-bottom: 0;">
                            <option value="usd">USD (TCGplayer Market)</option>
                            <option value="usd_foil">USD Foil (TCGplayer Market)</option>
                            <option value="eur">EUR (Cardmarket)</option>
                            <option value="tix">TIX (MTGO)</option>
                        </select>
                    </div>
                    <button onclick="savePrefs()" style="margin-bottom:30px; background:var(--green);">üíæ Save Preferences</button>

                    <h3 style="border-top:1px solid var(--border); padding-top:20px;">üè∑Ô∏è Collection Tags</h3>
                    <p style="color:var(--subtext); font-size:12px; margin-bottom:10px;">Define tags for quick access.</p>
                    <div class="input-group">
                        <input type="text" id="new-tag-input" placeholder="New Tag Name (e.g. Foil)...">
                        <button class="secondary" onclick="addCustomTag()" style="width:auto; margin-left:10px; padding: 10px 20px;">Add</button>
                    </div>
                    <div id="settings-tags-list" style="display:flex; flex-wrap:wrap; gap:8px; margin-bottom:30px;"></div>

                    <h3 style="border-top:1px solid var(--border); padding-top:20px;">üîê Security</h3>
                    <div class="input-group"><span class="input-icon">üîë</span><input type="password" id="new-password" placeholder="New Password"></div>
                    <button onclick="updatePassword()">Update Password</button>
                </div>
            </div>

            <div id="view-add" class="hidden">
                <div class="card-box" style="max-width:500px; margin:0 auto;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 20px;"><h2 style="margin:0;">Add Card</h2><button class="secondary" style="width:auto; font-size:12px; padding: 8px 12px; height: auto;" onclick="openBulkModal()">üìú Bulk Import</button></div>
                    <div class="input-group"><span class="input-icon">üîç</span><input type="text" id="search" placeholder="Search Card Name, or SET XXX (e.g., KTK 16)" oninput="debounceSearch()"></div>
                    <div style="margin-bottom:15px; font-size:12px; color:var(--primary); font-weight:600; min-height:15px;" id="search-status"></div>
                    <select id="versionSelect" onchange="updateSelectedVersion()" style="margin-bottom:15px; padding-left: 14px;"></select>
                    
                    <div style="display:flex; gap:10px; margin-bottom: 15px;">
                        <input id="set" placeholder="SET" readonly style="opacity:0.6; width:30%; padding-left: 14px;">
                        <input id="num" placeholder="#" readonly style="opacity:0.6; width:30%; padding-left: 14px;">
                        <input type="number" id="qty" placeholder="Qty" value="1" style="width:40%; padding-left: 14px;">
                    </div>
                    
                    <div class="input-group quantity-group"> 
                        <span class="input-icon">üí∞</span>
                        <input type="number" id="cost" placeholder="Acquisition Cost ($)" step="0.01" style="padding-left: 40px;">
                    </div>
                    
                    <div class="input-group quantity-group">
                        <span class="input-icon">üè∑Ô∏è</span>
                        <input type="text" id="add-tags" placeholder="Tags (e.g. Foil, Trade)..." style="padding-left: 40px;">
                    </div>
                    
                    <div id="quick-tags-area" style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:15px;"></div>

                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; font-size:12px; color:var(--subtext);">
                        <div style="display:flex; align-items:center; gap:5px;"><span>Price Source:</span>
                            <select id="priceSource" onchange="updateSelectedVersion(); savePrefs();" style="width:auto; padding:4px 8px; margin:0; font-size:11px;">
                                <option value="usd">üá∫üá∏ USD (TCG Market)</option>
                                <option value="usd_foil">‚ú® USD Foil (TCG Market)</option>
                                <option value="eur">üá™üá∫ EUR (Cardmarket)</option>
                                <option value="tix">üíª TIX (MTGO)</option>
                                <option value="global">üåé Global Avg (US+EU)</option>
                            </select>
                        </div>
                        <span id="marketPrice" style="color:var(--green); font-weight:700;">--</span>
                    </div>
                    <div style="text-align:center; min-height:200px; background:rgba(0,0,0,0.2); border-radius:10px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; border:1px dashed var(--border);"><img id="preview" style="max-width:90%; border-radius:8px; display:none; margin:10px 0;"><span id="preview-text" style="color:var(--subtext); font-size:12px;">Card Preview</span></div>
                    <div style="display:flex; gap:10px;">
                        <button onclick="addCard(false)" style="flex:2;">Bind to Collection</button>
                        <button onclick="addCard(true)" class="secondary" style="flex:1; border:1px solid var(--blue); color:var(--blue);">üëÅÔ∏è Add to Wishlist</button>
                    </div>
                </div>
            </div>
            
            <div id="view-collection" class="hidden">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                    <h2>Card Collection</h2>
                    <div style="display:flex; gap:10px;"><button id="btn-appraise" class="secondary" style="width:auto; padding:8px 16px; font-size:12px; background:var(--green); color:white; border:none;" onclick="appraiseCollection()">üîÑ Appraise Collection</button><button class="secondary" style="width:auto; padding:8px 16px; font-size:12px;" onclick="loadCollection()">Refresh</button></div>
                </div>
                <div id="appraisal-status" class="hidden" style="margin-bottom:15px; font-size:12px; color:var(--subtext);"></div>
                <div style="display:flex; gap:10px; margin-bottom:20px; align-items:center; flex-wrap:wrap;">
                    <div class="input-group" style="flex:1; margin-bottom:0;"><span class="input-icon">üîç</span><input id="vaultSearch" placeholder="Search Collection (Names or Tags)..." oninput="filterVault()" style="margin-bottom:0; padding-left: 40px;"></div>
                    <select id="vaultSort" onchange="filterVault(); savePrefs();" style="width:auto; min-width: 150px; margin-bottom:0; padding-left: 14px;"><option value="date-new">Date (Newest)</option><option value="price-high">Value (High $)</option><option value="name">Name (A-Z)</option></select>
                    <div class="view-toggle">
                        <div id="view-grid-btn" class="view-btn active" onclick="toggleVaultView('grid')">Grid</div>
                        <div id="view-list-btn" class="view-btn" onclick="toggleVaultView('list')">List</div>
                    </div>
                </div>
                <div id="collection-grid" class="collection-grid">
                    <div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div>
                </div>
            </div>

            <div id="view-oracle" class="hidden">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;"><h2 style="color:var(--blue);">üëÅÔ∏è Wishlist</h2><button class="secondary" style="width:auto; padding:8px 16px; font-size:12px;" onclick="loadOracle()">Refresh</button></div>
                <p style="color:var(--subtext); margin-bottom:20px;">Cards observed in the ether (Quantity: 0).</p>
                <div class="collection-grid" id="oracle-grid">
                    <div class="grid-card skeleton"></div><div class="grid-card skeleton" style="opacity:0.7;"></div><div class="grid-card skeleton" style="opacity:0.5;"></div>
                </div>
            </div>

            <div id="view-decks" class="hidden">
                <div id="deck-library">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                        <h2 style="margin:0;">Decklist Library</h2>
                        <div class="input-group" style="width:250px; margin:0;"><span class="input-icon">üîç</span><input id="deckSearch" placeholder="Search Decklists..." oninput="filterDecks()" style="margin:0; padding-left: 40px;"></div>
                    </div>
                    <div id="deck-grid-container" class="deck-grid"></div>
                </div>

                <div id="deck-workspace" class="hidden">
                    <button onclick="closeDeck()" class="secondary" style="width:auto; margin-bottom:15px; padding:8px 15px; font-size:12px;">‚Üê Back to Library</button>
                    
                    <div id="editor-mode" class="hidden">
                        <div class="card-box">
                            <div class="editor-header">
                                <input id="deckName" placeholder="Deck Name (e.g. Eldrazi Aggro)" style="margin:0; flex-grow:2; margin-right: 10px;">
                                <div class="input-group" style="margin:0; flex-grow:2;">
                                    <span class="input-icon">üëë</span>
                                    <input type="text" id="deckCommander" placeholder="Commander Name (Optional)" style="padding-left: 40px;">
                                </div>
                                <select id="deckFormat" style="margin:0; flex-grow:1; width:auto;">
                                    <option value="Casual">Casual</option><option value="Commander">Commander</option><option value="Modern">Modern</option><option value="Standard">Standard</option><option value="Pauper">Pauper</option><option value="Legacy">Legacy</option>
                                </select>
                                <button class="secondary clear-btn" onclick="clearDeckEditor()">üóëÔ∏è</button>
                            </div>
                            <div class="editor-split">
                                <div class="editor-column"><div class="editor-label">Mainboard</div><textarea id="deckMain" placeholder="1 Sol Ring..."></textarea></div>
                                <div class="editor-column"><div class="editor-label">Sideboard</div><textarea id="deckSide" placeholder="15 Island..."></textarea></div>
                            </div>
                            <div style="display:flex; gap:10px; margin-top:15px;">
                                <button id="validateDeckBtn" onclick="validateDeck()">‚úÖ Validate & Resolve</button>
                                <button onclick="saveDeck()" style="background:var(--green);">üíæ Save Decklist</button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="detail-mode" class="deck-area-detail hidden">
                        <div class="card-box">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                                <div style="flex-grow:1; display:flex; gap: 20px; align-items: flex-start;">
                                    <img id="detail-commander-img" style="width: 70px; height: 98px; border-radius: 6px; box-shadow: var(--shadow); display: none;">
                                    <div>
                                        <h3 id="detail-deck-name" style="margin:0; font-size:1.5rem; color:var(--primary);"></h3>
                                        <div id="detail-commander" style="font-size:14px; color:white; margin-bottom: 10px;"></div>
                                        <div style="font-size:11px; color:var(--subtext); margin-top:5px; display:flex; align-items:center; gap:8px;">OWNERSHIP: <span id="detail-owned-percent">0%</span><div class="progress-bg" style="width:100px; height:6px; margin:0;"><div id="detail-owned-bar" class="progress-fill" style="width:0%"></div></div></div>
                                    </div>
                                </div>
                                <div style="display:flex; gap:10px;">
                                    <button style="width:auto; padding:8px 16px; font-size:12px; background:var(--primary); color:white;" onclick="initBattlefield()">‚öîÔ∏è Playtest</button>
                                    <button style="width:auto; padding:8px 16px; font-size:12px; background:var(--green);" onclick="saveDeck()">üíæ Save</button>

                                    <div class="input-group" style="width: auto; margin: 0; position: relative;">
                                        <select id="tools-dropdown" onchange="handleDeckTool(this.value)" style="width: 100%; padding: 8px 14px; padding-left: 40px; font-size: 12px; height: 35px; background: rgba(255, 255, 255, 0.1); color: white;">
                                            <option value="">‚öôÔ∏è Tools & Export</option>
                                            <option value="edit">‚úçÔ∏è Edit Decklist</option>
                                            <option value="view_toggle">üëÅÔ∏è Toggle Visual/Text View</option>
                                            <option disabled>‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì</option>
                                            <option value="copy_missing">üìã Copy Missing Cards</option>
                                            <option value="buy">üõí Buy Missing Cards (TCGPlayer)</option>
                                            <option value="print">üñ®Ô∏è Print Proxies</option>
                                            <option disabled>‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì</option>
                                            <option value="export_arena">üéÆ Export MTG Arena</option>
                                            <option value="export_text">üì§ Export Text List</option>
                                        </select>
                                        <span class="input-icon" style="left: 10px; top: 50%; transform: translateY(-50%); font-size: 14px;">‚öôÔ∏è</span>
                                    </div>
                                </div>
                            </div>
                            <div id="detail-visual-grid" class="hidden visual-grid-container"></div>
                            <div class="deck-list-viewer" id="detail-decklist-viewer">Card list will appear here...</div>
                        </div>
                        <div class="card-box">
                            <h3>Deck Analysis</h3>
                            <div style="background:rgba(255,255,255,0.05); padding:15px; border-radius:8px; margin-bottom:15px; display:flex; align-items:center; justify-content:space-between;">
                                <span style="font-size:12px; color:var(--subtext); font-weight:600; text-transform:uppercase;">Estimated Value</span>
                                <span id="detail-deck-price" style="font-size:18px; font-weight:700; color:var(--green);">$0.00</span>
                            </div>
                            <div style="margin-bottom:15px;">
                                <button onclick="openLandCalculator()" class="secondary" style="width:100%; border:1px dashed var(--primary); color:var(--primary);">üèîÔ∏è The Geomancer (Mana Calc)</button>
                            </div>
                            <div id="detail-analysis-results" style="font-size:13px; color:var(--subtext);">Metrics will appear here.</div>
                            <div id="deck-charts" class="hidden"><div style="position:relative;"><canvas id="colorChart"></canvas></div><div style="position:relative;"><canvas id="typeChart"></canvas></div><div style="position:relative;"><canvas id="manaCurve"></canvas></div></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="view-battlefield" class="hidden">
                <div class="bf-hud">
                    <button class="secondary" style="width:auto; padding:5px 15px;" onclick="exitBattlefield()">‚Üê Exit</button>
                    <div class="bf-stat"><span style="color:var(--subtext);">Life:</span> <span id="bf-life" style="color:white; font-size:20px;">20</span> <div style="display:flex; gap:2px;"><button style="width:25px; padding:2px; font-size:12px;" onclick="updateLife(1)">+</button><button style="width:25px; padding:2px; font-size:12px;" onclick="updateLife(-1)">-</button></div></div>
                    <div class="bf-stat"><span style="color:var(--subtext);">Turn:</span> <span id="bf-turn">1</span> <button style="width:auto; padding:2px 8px; font-size:10px;" onclick="nextTurn()">Next</button></div>
                    <div class="bf-stat"><button style="width:auto; padding:5px 15px; background:var(--blue);" onclick="createToken()">+ Token</button> <button style="width:auto; padding:5px 15px; background:var(--red);" onclick="initBattlefield()">Reset Game</button></div>
                </div>
                <div class="bf-main">
                    <div id="bf-frontline" class="bf-row"><div class="bf-row-label">Combat / Spells</div></div>
                    <div id="bf-backline" class="bf-row"><div class="bf-row-label">Lands / Mana</div></div>
                </div>
                <div class="bf-hand-area">
                    <div class="bf-zone-btn" onclick="drawCard()"><div>üìö Library</div><div id="bf-lib-count" style="font-size:18px; font-weight:700;">0</div></div>
                    <div class="bf-zone-btn" style="border-color:var(--red);"><div>üíÄ Graveyard</div><div id="bf-grave-count" style="font-size:18px; font-weight:700;">0</div></div>
                    <div class="bf-zone-btn" style="border-color:var(--blue);"><div>üåÄ Exile</div><div id="bf-exile-count" style="font-size:18px; font-weight:700;">0</div></div>
                    <div id="bf-hand" style="display:flex; gap:10px; overflow-x:auto; padding:5px; flex:1;"></div>
                </div>
            </div>
        </div>

        <div class="bottom-nav">
            <div class="b-item active" onclick="nav('dashboard', 'dashboard')"><span class="b-icon">üè†</span>Dash</div>
            <div class="b-item" onclick="nav('add', 'add')"><span class="b-icon">‚ûï</span>Add</div>
            <div class="b-item" onclick="nav('collection', 'collection')"><span class="b-icon">üìö</span>Coll</div>
            <div class="b-item" onclick="nav('decks', 'decks')"><span class="b-icon">üìã</span>Decks</div>
        </div>
    </div>

    <script>
        // V5.0 BASELINE
        let currentDeckStructuredList = null; 
        
        // --- CONFIGURATION ---
        const SUPABASE_URL="https://mdirqlntcxqkthbwubmj.supabase.co", SUPABASE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1kaXJxbG50Y3hxa3RoYnd1Ym1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2OTUyOTAsImV4cCI6MjA4MTI3MTI5MH0.XBhYZiwINycA-QjAH-cL4vFzzyppm1c4M322jNDmbvE";
        const sb=supabase.createClient(SUPABASE_URL,SUPABASE_KEY);
        
        // V3.5.0: EMAILJS KEYS (REPLACE WITH YOUR OWN!)
        const EMAILJS_SERVICE_ID = 'service_n9utr47'; // PASTE YOUR SERVICE ID HERE
        const EMAILJS_TEMPLATE_ID = 'template_xtth5gu'; // PASTE YOUR TEMPLATE ID HERE
        const EMAILJS_PUBLIC_KEY = 'ohGLAW9gp3OUPH0uf'; // PASTE YOUR PUBLIC KEY HERE

        let vaultLookup = {}; // V5.1: Global for ownership lookup
        let typeChartInstance = null, manaCurveInstance = null, colorChartInstance = null; // V5.1: Removed priceChartInstance
        let session=null, tempCardData=null, allVersions=[], searchTimer, cardsCache=[], currentViewedDeckId=null, isResetMode=false;
        let currentDeckCache=[], currentDeckCoverUrl='';
        let vaultViewMode = localStorage.getItem('grimoire_view') || 'grid';
        const CHART_COLORS=['#a78bfa','#dc2626','#a78bfa','#4f46e5','#059669','#737373','#facc15'];
        let suggestedLands = [];
        let gameState = { lib: [], hand: [], field: [], grave: [], exile: [], life: 20, turn: 1 }; // Game state for battlefield

        // --- UTILITIES ---
        function openUserOptionsModal() {
            document.getElementById('user-options-modal').classList.remove('hidden');
        }
        function closeUserOptionsModal() {
            document.getElementById('user-options-modal').classList.add('hidden');
        }
        
        // V6.0: savePrefs Update
        function savePrefs() { 
            localStorage.setItem('grimoire_view', vaultViewMode); 
            localStorage.setItem('grimoire_sort', document.getElementById('vaultSort').value); 
            
            // V6.0: Save the new preferred price source setting
            if (document.getElementById('settingsPriceSource')) {
                localStorage.setItem('grimoire_default_price_source', document.getElementById('settingsPriceSource').value);
            }
            // V6.0: Update price display dropdown in Add Card view immediately if present
            if (document.getElementById('priceSource')) {
                 document.getElementById('priceSource').value = localStorage.getItem('grimoire_default_price_source') || 'usd';
            }
            
            showToast("Preferences saved!", "success");
        }

        // V6.0: loadPrefs Update
        function loadPrefs() { 
            const defaultPriceSource = localStorage.getItem('grimoire_default_price_source') || 'usd';

            if(localStorage.getItem('grimoire_sort') && document.getElementById('vaultSort')) 
                document.getElementById('vaultSort').value = localStorage.getItem('grimoire_sort'); 
            
            // V6.0: Load the default price source into both dropdowns
            if(document.getElementById('priceSource')) 
                document.getElementById('priceSource').value = localStorage.getItem('grimoire_price') || defaultPriceSource; 
            
            if(document.getElementById('settingsPriceSource'))
                document.getElementById('settingsPriceSource').value = defaultPriceSource;

            if(localStorage.getItem('grimoire_theme')) applyTheme(localStorage.getItem('grimoire_theme'));
            toggleVaultView(vaultViewMode); 
        }

        // V6.1: Custom Tag Logic
        let customTags = JSON.parse(localStorage.getItem('grimoire_custom_tags')) || ['Foil', 'Trade', 'Damaged', 'Signed'];

        function saveCustomTags() {
            localStorage.setItem('grimoire_custom_tags', JSON.stringify(customTags));
            renderTagManager();
            renderQuickTags();
        }

        function addCustomTag() {
            const input = document.getElementById('new-tag-input');
            const val = input.value.trim();
            if (val && !customTags.includes(val)) {
                customTags.push(val);
                saveCustomTags();
                input.value = '';
            }
        }

        function removeCustomTag(tag) {
            customTags = customTags.filter(t => t !== tag);
            saveCustomTags();
        }

        function renderTagManager() {
            const container = document.getElementById('settings-tags-list');
            if (!container) return;
            container.innerHTML = customTags.map(tag => 
                `<div class="tag-pill" style="font-size:12px; padding:6px 12px; cursor:default;">
                    ${tag} <span onclick="removeCustomTag('${tag}')" style="margin-left:8px; cursor:pointer; opacity:0.6;">‚úï</span>
                </div>`
            ).join('');
        }

        function renderQuickTags() {
            const container = document.getElementById('quick-tags-area');
            if (!container) return;
            const currentVal = document.getElementById('add-tags').value;
            
            container.innerHTML = customTags.map(tag => {
                const isActive = currentVal.includes(tag);
                const bg = isActive ? 'var(--primary)' : 'rgba(255,255,255,0.1)';
                return `<div class="tag-pill" onclick="toggleQuickTag('${tag}')" style="background:${bg}; font-size:10px; padding:4px 10px; cursor:pointer; border:1px solid var(--border);">
                    ${tag}
                </div>`;
            }).join('');
        }

        function toggleQuickTag(tag) {
            const input = document.getElementById('add-tags');
            let val = input.value;
            let tags = val.split(',').map(t => t.trim()).filter(t => t.length > 0);
            
            if (tags.includes(tag)) {
                tags = tags.filter(t => t !== tag);
            } else {
                tags.push(tag);
            }
            
            input.value = tags.join(', ');
            renderQuickTags(); // Re-render to update active state styling
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '167, 139, 250';
        }
        // V4.0.17: Updated showToast to auto-hide after 3 seconds
        function showToast(m,t='info'){ 
            let c=document.getElementById('toast-container');
            if(!c){c=document.createElement('div');c.id='toast-container';document.body.appendChild(c)} 
            
            const el=document.createElement('div');
            el.className=`toast ${t}`;
            el.innerHTML=`<span>${m}</span><span style="cursor:pointer;opacity:0.5;" onclick="this.parentElement.remove()">‚úï</span>`;
            c.appendChild(el);
            
            // Set timeout for auto-removal
            setTimeout(()=>{
                el.classList.add('hiding');
                el.addEventListener('transitionend',()=>el.remove());
            }, 3000); 
        }
        function getCardImage(c) { 
            if(!c) return ''; 
            
            // V4.0.4: Check Local Cache First (improves performance significantly)
            const setCode = c.set_code || c.set;
            const num = c.collector_number || c.num;

            if (!setCode || !num) {
                 return c.image_url || (c.image_uris && c.image_uris.normal) || (c.card_faces && c.card_faces[0].image_uris && c.card_faces[0].image_uris.normal) || '';
            }

            const cacheKey = `img_cache_${setCode}_${num}`;
            const cachedUrl = localStorage.getItem(cacheKey);
            if (cachedUrl) {
                return cachedUrl;
            }

            let imageUrl = '';
            if(c.image_url) imageUrl = c.image_url; 
            else if(c.image_uris && c.image_uris.normal) imageUrl = c.image_uris.normal; 
            else if(c.card_faces && c.card_faces[0].image_uris && c.card_faces[0].image_uris.normal) imageUrl = c.card_faces[0].image_uris.normal; 
            
            if (imageUrl) {
                localStorage.setItem(cacheKey, imageUrl);
            }
            
            return imageUrl; 
        }

        // --- V3.5.0 BUG REPORT ---
        async function reportBug() {
            const description = document.getElementById('bug-description').value;
            if (description.length < 10) return showToast("Please provide a longer description.", "error");

            if (EMAILJS_SERVICE_ID === 'YOUR_SERVICE_ID' || EMAILJS_PUBLIC_KEY === 'YOUR_PUBLIC_KEY') {
                document.getElementById('report-modal').classList.add('hidden');
                return showToast("Bug reporting is not set up. Check configuration keys.", "error");
            }
            
            emailjs.init(EMAILJS_PUBLIC_KEY);

            const templateParams = {
                bug_description: description,
                user_email: session?.user?.email || 'Anonymous/Logged Out',
                app_version: 'v6.1',
                browser_info: navigator.userAgent
            };

            try {
                await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, templateParams);
                showToast("Bug report sent! Thank you.", "success");
                document.getElementById('report-modal').classList.add('hidden');
                document.getElementById('bug-description').value = '';
            } catch (error) {
                showToast("Failed to send report. Try checking your EmailJS setup.", "error");
                console.error('EmailJS Failed:', error);
            }
        }
        
        // --- AUTH & PROFILE ---
        function toggleResetMode(){ isResetMode=!isResetMode; const g=document.getElementById('password').parentElement; if(isResetMode){g.classList.add('hidden');document.getElementById('auth-btn').innerText="Send Recovery";document.getElementById('forgot-link').innerText="Back";}else{g.classList.remove('hidden');document.getElementById('auth-btn').innerText="Summon Session";document.getElementById('forgot-link').innerText="Forgot Password?";}}
        async function handleAuthAction(){if(isResetMode){const e=document.getElementById('email').value;const{error}=await sb.auth.resetPasswordForEmail(e,{redirectTo:window.location.href});if(error)showToast(error.message,"error");else showToast("Check email!","success")}else{const e=document.getElementById('email').value,p=document.getElementById('password').value;let{data,error}=await sb.auth.signInWithPassword({email:e,password:p});if(error){if(error.message.includes("Invalid login credentials")){showToast("Invalid credentials. Attempting creation...","info");const sup=await sb.auth.signUp({email:e,password:p});if(sup.error){showToast(sup.error.message,"error");}else{if(sup.data.session)finalizeLogin(sup.data.session);else showToast("Account created! Check email.","success");}}else{showToast(error.message,"error");}}else{finalizeLogin(data.session);}}}
        function finalizeLogin(s){
            session=s;
            document.getElementById('auth-screen').classList.add('hidden');
            document.getElementById('app').classList.remove('hidden');
            document.getElementById('user-email').innerText=s.user.email;
            loadData(); loadPrefs(); loadProfile(); 
        }
        async function handleLogout(){
            await sb.auth.signOut();
            window.location.reload();
        }
        
        async function loadProfile() { 
            const { data, error } = await sb.from('profiles').select('*').eq('id', session.user.id).single(); 
            if (data) { 
                if(data.username) { document.getElementById('sidebar-username').innerText = data.username; document.getElementById('settings-username').value = data.username; } 
                if(data.avatar_url) { document.getElementById('sidebar-avatar').src = data.avatar_url; document.getElementById('settings-avatar').src = data.avatar_url; } 
            } else { 
                await sb.from('profiles').upsert({ id: session.user.id, username: 'Wizard', avatar_url: 'https://svgshare.com/i/10gq.svg' }); 
            } 
        }
        async function saveProfile() { 
            const username = document.getElementById('settings-username').value; 
            const avatar = document.getElementById('settings-avatar').src; 
            const { error } = await sb.from('profiles').upsert({ id: session.user.id, username, avatar_url: avatar, updated_at: new Date() }); 
            if(error) showToast("Error saving profile", "error"); 
            else { showToast("Identity Updated!", "success"); loadProfile(); } 
        }
        async function updatePassword() { 
            const p = document.getElementById('new-password').value; 
            if(!p) return showToast("Enter a password", "error"); 
            const { error } = await sb.auth.updateUser({ password: p }); 
            if(error) showToast(error.message, "error"); 
            else { showToast("Password updated!", "success"); document.getElementById('new-password').value = ""; } 
        }
        function openAvatarModal() { 
            document.getElementById('avatar-modal').classList.remove('hidden'); 
            const grid = document.getElementById('avatar-grid'); 
            const avatarOptions = cardsCache.filter(c=>c.image_url).slice(0, 50);

            grid.innerHTML = avatarOptions.map(c => `<img src="${getCardImage(c)}" class="avatar-option" onclick="setAvatar('${getCardImage(c)}')">`).join(''); 
        }
        function setAvatar(url) { document.getElementById('settings-avatar').src = url; document.getElementById('avatar-modal').classList.add('hidden'); }
        
        // --- NAVIGATION & DATA LOADING ---
        function nav(v,i){ 
            document.querySelectorAll('.main > div').forEach(d=>d.classList.add('hidden')); 
            document.getElementById('view-'+v).classList.remove('hidden'); 
            document.querySelectorAll('.nav-item').forEach(el=>el.classList.remove('active')); 
            document.querySelectorAll('.b-item').forEach(el=>el.classList.remove('active')); 
            
            if (i) document.querySelector(`.b-item[onclick="nav('${v}', '${i}')"]`).classList.add('active');
            else document.querySelector(`.nav-item[onclick="nav('${v}', '${v}')"]`).classList.add('active');

            if(v==='decks'){ 
                loadDecks(); 
            } else { 
                document.getElementById('deck-workspace').classList.add('hidden'); 
                document.getElementById('deck-library').classList.remove('hidden'); 
                showRitualEditor(false); 
                clearCharts(); 
            } 
            if(v==='collection') loadCollection(); 
            if(v==='oracle') loadOracle(); 
            
            // V6.1: Render tags when entering relevant screens
            if(v==='settings') renderTagManager();
            if(v==='add') renderQuickTags();
        }
        function debounceSearch(){ clearTimeout(searchTimer); searchTimer=setTimeout(fetchCardMeta,500); }

        async function fetchCardMeta(){ 
            const n=document.getElementById('search').value.trim(); 
            if(n.length<3) return;
            
            document.getElementById('search-status').innerText = "Consulting Scryfall...";

            let searchQuery = `q=${encodeURIComponent(n)}&unique=prints`; // Default: search by name
            let apiUrl = `https://api.scryfall.com/cards/search?`;

            // V4.0.0: Check for ID/Set Code Pattern
            const setNumMatch = n.match(/^([a-z]{3,4})\s*(\d+)$/i);
            const idMatch = n.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);

            if (setNumMatch) {
                const setCode = setNumMatch[1].toLowerCase();
                const collectorNumber = setNumMatch[2];
                apiUrl = `https://api.scryfall.com/cards/${setCode}/${collectorNumber}?`;
                searchQuery = ``; 
            } else if (idMatch) {
                apiUrl = `https://api.scryfall.com/cards/${idMatch[0]}?`;
                searchQuery = ``;
            }

            try{ 
                const res = await fetch(apiUrl + searchQuery); 
                const d = await res.json(); 

                // V4.0.17: Improved Error Check - Check if response succeeded AND if data exists
                if (d.object === "error" && !d.data) {
                    document.getElementById('search-status').innerText = `Error: ${d.details}`;
                    return showToast("Card not found in archives.", "error");
                }

                if (setNumMatch || idMatch) {
                    allVersions = [d];
                } else if (d.data) {
                    allVersions = d.data;
                } else {
                     document.getElementById('search-status').innerText = `No cards found matching "${n}"`;
                     allVersions = [];
                }
                
                // If we got data, but the initial API call reported an error (like a fuzzy match warning), only show status, not the loud toast.
                const statusMessage = `${allVersions.length} versions found.`;
                document.getElementById('search-status').innerText = statusMessage;
                if (d.object === "error") {
                    console.warn(`Scryfall Warning: ${d.details}`);
                }
                
                if (allVersions.length === 0) {
                     return showToast("No cards found.", "error");
                }

                const s=document.getElementById('versionSelect'); 
                s.innerHTML=''; 
                allVersions.forEach((v,i)=>{ 
                    const price = v.prices.usd || 'N/A';
                    const o=document.createElement('option'); 
                    o.value=i; 
                    o.text=`${v.set_name} - $${price}`; 
                    s.appendChild(o); 
                }); 
                
                updateSelectedVersion(); 

            } catch(e){
                document.getElementById('search-status').innerText = `Network Error.`;
                showToast("Could not contact Scryfall API.", "error");
            } 
        }
        
        // V6.0: updateSelectedVersion Update (Use Saved Default)
        function updateSelectedVersion(){ 
            const index = document.getElementById('versionSelect').value;
            const v = allVersions[index];
            
            if(!v) return;

            const selectedSource = document.getElementById('priceSource').value || 'usd';
            let rawPrice = v.prices[selectedSource] || v.prices.usd || 0; // Fallback to USD if selected source is missing
            const usd = parseFloat(v.prices.usd || 0);
            const eur = parseFloat(v.prices.eur || 0);

            let displayPrice;
            let displayDetails = '';

            if (selectedSource === 'global' && eur > 0) {
                // Global is a special calculated average (kept for compatibility)
                const calculatedPrice = (usd + (eur * 1.05)) / 2;
                displayPrice = calculatedPrice.toFixed(2);
                displayDetails = `($${usd.toFixed(2)} US / ‚Ç¨${eur.toFixed(2)} EU)`;
            } else {
                displayPrice = parseFloat(rawPrice).toFixed(2);
            }
            
            const priceHtml = `$${displayPrice} <span style='font-size:10px; color:var(--subtext);'>${displayDetails}</span>`;
            
            document.getElementById('set').value = v.set.toUpperCase(); 
            document.getElementById('num').value = v.collector_number; 
            document.getElementById('marketPrice').innerHTML = priceHtml; 
            
            const imageUrl = getCardImage(v); 
            
            const preview = document.getElementById('preview'); 
            preview.src = imageUrl; 
            preview.style.display = 'block'; 
            document.getElementById('preview-text').style.display = 'none'; 
            
            tempCardData = { 
                name: v.name, 
                set: v.set.toUpperCase(), 
                num: v.collector_number, 
                img: imageUrl, 
                // V6.0: Store the raw price value (which might be the selected source or the fallback USD)
                market_price: parseFloat(rawPrice) 
            }; 

            // V4.0.3: RESTORATION - Collection Management requires NO deck limits.
            const qtyInput = document.getElementById('qty');
            const costGroup = document.querySelector('.input-group.quantity-group:nth-child(2)');
            const tagsGroup = document.querySelector('.input-group.quantity-group:nth-child(3)');
            
            // 1. Ensure all inputs are visible (Default Collection Management UX)
            costGroup.classList.remove('hidden');
            tagsGroup.classList.remove('hidden');

            // 2. Remove all limits/locks on Quantity input
            qtyInput.value = 1;
            qtyInput.max = 999; // Set a high arbitrary max, effectively unlimited
            qtyInput.readOnly = false;
        }
        
        // V4.0.17: Updated Add Card to handle Wishlist correctly (honors qty, 0 is Wishlist)
        async function addCard(isWishlist = false) { 
            if(!tempCardData) return showToast("Search and select a Card version first", "error"); 
            const costInput = document.getElementById('cost').value; 
            let qty = parseInt(document.getElementById('qty').value) || 1; 
            
            // If explicitly adding to wishlist, quantity is 0 (overrides user input if not 0)
            if(isWishlist) {
                // We save 0 to DB for wishlist, which overrides user input for the DB quantity.
                // We keep the logic simple: if it's the wishlist button, qty = 0.
                qty = 0; 
            } else if(qty <= 0) {
                 return showToast("Quantity must be greater than zero to bind to Collection.", "error"); 
            }
            
            const costToSave = costInput.length > 0 ? parseFloat(costInput) : null; 
            const tagStr = document.getElementById('add-tags').value; 
            const tags = tagStr ? tagStr.split(',').map(t => t.trim()).filter(t => t.length > 0) : []; 
            
            const { error } = await sb.from('cards').insert({ 
                user_id: session.user.id, 
                name: tempCardData.name, 
                set_code: tempCardData.set, 
                collector_number: tempCardData.num, 
                image_url: tempCardData.img, 
                buy_price: costToSave, 
                quantity: qty, 
                market_price_usd: tempCardData.market_price, 
                tags: tags, 
                last_price_update: new Date().toISOString() 
            }); 
            
            if(!error) { 
                if(isWishlist) showToast(`üëÅÔ∏è Added ${tempCardData.name} to Wishlist!`, "success"); 
                else showToast(`‚úÖ Added ${qty}x ${tempCardData.name} to Collection!`, "success"); 
                
                // Clear inputs after successful add
                document.getElementById('search').value = ""; 
                document.getElementById('cost').value = ""; 
                document.getElementById('qty').value = "1"; 
                document.getElementById('add-tags').value = ""; 
                document.getElementById('versionSelect').innerHTML = ''; 
                document.getElementById('preview').style.display = 'none'; 
                document.getElementById('search-status').innerText = ""; 
                document.getElementById('set').value = ''; 
                document.getElementById('num').value = ''; 
                document.getElementById('marketPrice').innerText = '--'; 
                
                // V6.1: Refresh quick tags state
                renderQuickTags();
                
                tempCardData = null; 
                
                loadData(); 
            } else { 
                showToast(error.message, "error"); 
            } 
        }

        function openBulkModal() { 
            document.getElementById('bulk-modal').classList.remove('hidden'); 
        }
        function closeBulkModal() { document.getElementById('bulk-modal').classList.add('hidden'); document.getElementById('bulkList').value = ''; document.getElementById('bulk-status').innerText = ''; }
        
        async function processBulkImport() { 
            const text = document.getElementById('bulkList').value; 
            const statusEl = document.getElementById('bulk-status'); 
            if(!text.trim()) return showToast("Please paste a list first.", "error"); 
            const { cards } = parseDeckList(text); 
            if(cards.length === 0) return showToast("No valid cards found.", "error"); 
            statusEl.innerText = `Resolving ${cards.length} cards via Scryfall...`; 
            const identifiers = cards.map(c => ({ name: c.name })); 
            const chunkSize = 75; 
            const totalChunks = Math.ceil(identifiers.length / chunkSize); 
            let finalInserts = []; 
            try { 
                for (let i = 0; i < totalChunks; i++) { 
                    statusEl.innerText = `Resolving Batch ${i+1}/${totalChunks}...`;
                    const chunk = identifiers.slice(i * chunkSize, (i + 1) * chunkSize); 
                    const response = await fetch('https://api.scryfall.com/cards/collection', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ identifiers: chunk }) 
                    }); 
                    const data = await response.json(); 
                    data.data.forEach(scryCard => { 
                        const originalInput = cards.find(c => c.name.toLowerCase() === scryCard.name.toLowerCase()) || cards.find(c => scryCard.name.toLowerCase().includes(c.name.toLowerCase())); 
                        if(originalInput) { 
                            const img = getCardImage(scryCard); 
                            const price = scryCard.prices.usd || scryCard.prices.usd_foil || 0; 
                            finalInserts.push({ 
                                user_id: session.user.id, 
                                name: scryCard.name, 
                                set_code: scryCard.set.toUpperCase(), 
                                collector_number: scryCard.collector_number, 
                                image_url: img, 
                                buy_price: null, 
                                quantity: originalInput.qty, 
                                market_price_usd: parseFloat(price), 
                                last_price_update: new Date().toISOString() 
                            }); 
                        } 
                    }); 
                    await new Promise(r => setTimeout(r, 100)); // Be nice to the API
                } 
                if(finalInserts.length > 0) { 
                    statusEl.innerText = `Binding ${finalInserts.length} cards to Collection...`; 
                    const { error } = await sb.from('cards').insert(finalInserts); 
                    if(error) throw error; 
                    showToast(`‚úÖ Successfully bound ${finalInserts.length} cards!`, "success"); 
                    closeBulkModal(); 
                    loadData(); 
                } else { 
                    statusEl.innerText = "Could could not identify any cards."; 
                } 
            } catch(e) { 
                statusEl.innerText = "Error: " + e.message; 
            } 
        }

        async function logDailyValue(totalVal) {
            // This function is kept to avoid breaking older functions that called it, but is empty due to V5.1 stabilization.
            console.log("[LOG] Skipping daily value logging (Removed for stabilization).");
        }

        async function loadPriceHistory() {
            // This function is kept but returns an empty array to avoid breaking the Chart component if it was not fully removed.
            return [];
        }

        async function loadData() { 
            const { data: cards, error } = await sb.from('cards').select('*').order('created_at', { ascending: false }); 
            if(error) return console.error(error); 
            cardsCache = cards; 

            // V5.1: Reset lookup map and populate it for faster ownership checking
            vaultLookup = {};
            cardsCache.forEach(c => { 
                c.set = c.set_code || c.set;
                c.num = c.collector_number || c.num;
                // Use a standard unique identifier: card name + set code + collector number
                const key = `${c.name.toLowerCase().trim()}_${c.set}_${c.num}`;
                
                // Track total quantity owned for each unique card printing
                vaultLookup[key] = (vaultLookup[key] || 0) + c.quantity;
            });
        
            let totalVal = 0, totalCost = 0, count = 0, oracleCost = 0; 
            cards.forEach(c => { if (c.quantity > 0) { count += c.quantity; if (c.buy_price !== null && Number(c.buy_price) > 0) totalCost += Number(c.buy_price) * c.quantity; totalVal += (Number(c.market_price_usd || 0) * c.quantity); } else { oracleCost += Number(c.market_price_usd || 0); } }); 
            
            document.getElementById('stat-count').innerText = count; 
            document.getElementById('stat-cost').innerText = "$" + totalCost.toFixed(2); 
            document.getElementById('stat-value').innerText = "$" + totalVal.toFixed(2); 
            document.getElementById('stat-oracle').innerText = "$" + oracleCost.toFixed(2); 
            const gain = totalVal - totalCost; 
            const gainEl = document.getElementById('stat-gain'); 
            gainEl.innerText = `$${gain.toFixed(2)}`; 
            gainEl.style.color = gain >= 0 ? 'var(--green)' : 'var(--red)'; 
            
            document.querySelectorAll('.stat-val').forEach(el => el.classList.remove('skeleton'));
            document.getElementById('top-assets-list').innerHTML = '';
            document.getElementById('recent-grid').innerHTML = '';

            const ownedCards = cards.filter(c => c.quantity > 0); 
            if(ownedCards.length > 0) { 
                const recent = ownedCards.slice(0, 5); 
                document.getElementById('recent-grid').innerHTML = recent.map(c => ` <div class="grid-card"><img src="${getCardImage(c)}" loading="lazy" onload="this.style.opacity=1" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')"><div class="overlay"><span>${c.name.substring(0, 15)}...</span><span>$${Number(c.market_price_usd || 0).toFixed(2)}</span></div></div> `).join(''); 
            } else { 
                document.getElementById('recent-grid').innerHTML = '<div style="color:var(--subtext); padding:20px; font-size:13px; grid-column:1/-1; text-align:center;">No cards found. Go to \'Add Card\' to start!</div>'; 
            } 
            const topAssets = [...ownedCards].sort((a,b) => (b.market_price_usd || 0) - (a.market_price_usd || 0)).slice(0, 5); 
            if (topAssets.length > 0 && topAssets[0].market_price_usd > 0) { 
                document.getElementById('top-assets-list').innerHTML = topAssets.map(c => ` <div class="asset-row"> <div class="asset-info"><img src="${getCardImage(c)}" class="asset-img" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')"><div><div style="font-weight:600; font-size:14px;">${c.name}</div><div style="font-size:11px; color:var(--subtext);">${c.set_code || c.set} #${c.collector_number || c.num}</div></div></div> <div class="asset-val">$${Number(c.market_price_usd).toFixed(2)}</div> </div> `).join(''); 
            } else { 
                document.getElementById('top-assets-list').innerHTML = '<div style="color:var(--subtext); padding:20px; text-align:center;">No valuable cards found.</div>'; 
            } 
            
            // logDailyValue(totalVal); // REMOVED V5.1
            // loadPriceHistory().then(renderPriceHistoryChart); // REMOVED V5.1
        }

        async function appraiseCollection(){ 
            if(cardsCache.length===0) return showToast("Collection is empty. Add cards first.", "info"); 
            const btn=document.getElementById('btn-appraise'); 
            const status=document.getElementById('appraisal-status'); 
            btn.disabled=true; 
            btn.innerText="Appraising..."; 
            status.classList.remove('hidden'); 
            status.innerText="Contacting market oracles..."; 
            
            const ids=cardsCache.map(c=>({set:c.set_code.toLowerCase(),collector_number:c.collector_number})); 
            const chunkSize=75; 
            const totalChunks=Math.ceil(ids.length/chunkSize); 
            
            try { 
                for(let i=0; i<totalChunks; i++){ 
                    status.innerText = `Processing Batch ${i+1}/${totalChunks}...`;
                    const chunk = ids.slice(i*75,(i+1)*75); 
                    const res=await fetch('https://api.scryfall.com/cards/collection',{
                        method:'POST',
                        headers:{'Content-Type':'application/json'},
                        body:JSON.stringify({identifiers:chunk})
                    }); 
                    const d=await res.json(); 
                    if(d.data) { 
                        for(const sc of d.data){ 
                            const local=cardsCache.find(c=>c.set_code.toLowerCase()===sc.set && c.collector_number===sc.collector_number); 
                            if(local){ 
                                const np=parseFloat(sc.prices.usd||0); 
                                await sb.from('cards').update({market_price_usd:np, last_price_update: new Date().toISOString()}).eq('id',local.id); 
                                local.market_price_usd=np; 
                            } 
                        } 
                    } 
                    await new Promise(r => setTimeout(r, 100)); // Be nice to the API
                } 
                showToast("Appraisal Complete!","success"); 
                loadData(); 
                filterVault(); 
            } catch(e) { 
                showToast("Appraisal failed","error"); 
                console.error(e); 
            } finally { 
                btn.disabled=false; 
                btn.innerText="üîÑ Appraise Collection"; 
                status.classList.add('hidden'); 
            } 
        }
        
        function loadCollection(){ 
            if(!cardsCache.length) loadData(); 
            document.getElementById('collection-grid').innerHTML = '<div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div><div class="grid-card skeleton"></div>';
            filterVault(); 
        }
        function toggleVaultView(mode) { vaultViewMode = mode; savePrefs(); document.getElementById('view-grid-btn').classList.toggle('active', mode === 'grid'); document.getElementById('view-list-btn').classList.toggle('active', mode === 'list'); document.getElementById('collection-grid').className = mode === 'grid' ? 'collection-grid' : ''; filterVault(); }
        function showPreview(url, e) { const el = document.getElementById('hover-preview'); if(!url) return; el.src = url; el.style.display = 'block'; el.style.left = (e.clientX + 20) + 'px'; el.style.top = e.clientY + 'px'; }
        function hidePreview() { document.getElementById('hover-preview').style.display = 'none'; }
        function filterVault(){ const t=document.getElementById('vaultSearch').value.toLowerCase(); const s=document.getElementById('vaultSort').value; let f=cardsCache.filter(c=>c.quantity>0 && c.name.toLowerCase().includes(t)); if(t.startsWith('#')) { const tagSearch = t.substring(1); f = cardsCache.filter(c => c.quantity > 0 && c.tags && c.tags.some(tag => tag.toLowerCase().includes(tagSearch))); } if(s==='price-high')f.sort((a,b)=>b.market_price_usd-a.market_price_usd); else f.sort((a,b)=>new Date(b.created_at)-new Date(a.created_at)); const container = document.getElementById('collection-grid'); if (vaultViewMode === 'list') { let html = `<table class="vault-table"><thead><tr><th>Img</th><th>Name</th><th>Set</th><th>Qty</th><th>Price</th><th>Tags</th><th>Edit</th></tr></thead><tbody>`; html += f.map(c => ` <tr onmouseenter="showPreview('${getCardImage(c)}', event)" onmouseleave="hidePreview()"> <td><img src="${getCardImage(c)}" class="list-img" loading="lazy" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')"></td> <td style="font-weight:600; cursor:pointer;" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')">${c.name}</td> <td style="color:var(--subtext);">${c.set_code || c.set} #${c.collector_number || c.num}</td> <td>${c.quantity}</td> <td style="color:var(--green);">$${Number(c.market_price_usd).toFixed(2)}</td> <td>${c.tags ? c.tags.map(tag => `<span style="font-size:10px; background:rgba(255,255,255,0.1); padding:2px 4px; border-radius:3px; margin-right:2px;">${tag}</span>`).join('') : ''}</td> <td><button class="secondary" style="padding:4px 8px; width:auto;" onclick="openEditModal('${c.id}', event)">‚úé</button></td> </tr> `).join(''); html += `</tbody></table>`; container.innerHTML = html; } else { container.innerHTML=f.map(c=>{ let badge=''; if(c.buy_price && c.market_price_usd){ const diff=c.market_price_usd-c.buy_price; const color=diff>=0?'var(--green)':'var(--red)'; const sign=diff>=0?'+':''; badge=`<div class="gain-badge" style="color:${color}">${sign}$${diff.toFixed(2)}</div>`; } let tagHtml = ''; if(c.tags && c.tags.length > 0) { tagHtml = `<div class="tag-container">${c.tags.map(tag => `<div class="tag-pill">${tag}</div>`).join('')}</div>`; } return `<div class="grid-card" id="card-${c.id}">${badge}${tagHtml}<div class="overlay"><button onclick="openEditModal('${c.id}',event)">‚úé</button><button onclick="deleteCard('${c.id}',event)">üóëÔ∏è</button></div><img src="${getCardImage(c)}" loading="lazy" onload="this.style.opacity=1" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')"></div>` }).join(''); } }
        function loadOracle(){ 
            const f=cardsCache.filter(c=>c.quantity===0); 
            document.getElementById('oracle-grid').innerHTML = f.length > 0 ? 
                f.map(c=>`<div class="grid-card" style="border-color:var(--blue);"><div class="overlay"><button onclick="deleteCard('${c.id}',event)">üóëÔ∏è</button></div><img src="${getCardImage(c)}" loading="lazy" onload="this.style.opacity=1" onclick="openCodex('${c.set_code || c.set}', '${c.collector_number || c.num}')"></div>`).join('') : 
                '<div style="color:var(--subtext); padding:20px; font-size:13px; grid-column:1/-1; text-align:center;">No cards in the Wishlist.</div>';
        }
        
        let pendingDeleteId = null;
        function askDeleteDeck(id, e) { e.stopPropagation(); const deck = window.myDecks.find(d => d.id == id); if(!deck) return; pendingDeleteId = id; document.getElementById('delete-target-name').innerText = deck.name; document.getElementById('delete-modal').classList.remove('hidden'); }
        function closeDeleteModal() { document.getElementById('delete-modal').classList.add('hidden'); pendingDeleteId = null; }
        async function confirmDelete() { if (!pendingDeleteId) return; const btn = document.querySelector('#delete-modal button'); const originalText = btn.innerText; btn.innerText = "Burning..."; if (currentViewedDeckId == pendingDeleteId) { showRitualEditor(false); } await sb.from('decks').delete().eq('id', pendingDeleteId); showToast("Decklist sacrificed to the void.", "success"); loadDecks(); closeDeleteModal(); btn.innerText = originalText; }
        async function deleteCard(id, e) { e.stopPropagation(); if(!confirm("Are you sure you want to sacrifice this card?")) return; const cardEl = document.getElementById(`card-${id}`); if(cardEl) cardEl.style.display = 'none'; cardsCache = cardsCache.filter(c => c.id !== Number(id)); const { error } = await sb.from('cards').delete().eq('id', id); if(error) { showToast(`Error: ${error.message}`, "error"); if(cardEl) cardEl.style.display = 'block'; } else { showToast("Card sacrificed.", "success"); } loadData(); filterVault(); loadOracle(); }
        function openEditModal(id, e) { e.stopPropagation(); const card = cardsCache.find(c => c.id == id); if(!card) return; document.getElementById('edit-card-id').value = id; document.getElementById('edit-card-name').innerText = `Edit: ${card.name}`; document.getElementById('edit-qty').value = card.quantity; document.getElementById('edit-cost').value = card.buy_price || ''; document.getElementById('edit-tags').value = (card.tags || []).join(', '); document.getElementById('edit-modal').classList.remove('hidden'); }
        async function saveEdit() { const id = document.getElementById('edit-card-id').value; const qty = document.getElementById('edit-qty').value; const cost = document.getElementById('edit-cost').value; const tagStr = document.getElementById('edit-tags').value; const tags = tagStr.split(',').map(t => t.trim()).filter(t => t.length > 0); if(qty < 0) return showToast("Quantity cannot be negative", "error"); const costVal = cost ? parseFloat(cost) : null; const { error } = await sb.from('cards').update({ quantity: parseInt(qty), buy_price: costVal, tags: tags }).eq('id', id); if(error) { showToast(error.message, "error"); } else { showToast("Card updated.", "success"); document.getElementById('edit-modal').classList.add('hidden'); const idx = cardsCache.findIndex(c => c.id == id); if(idx !== -1) { cardsCache[idx].quantity = parseInt(qty); cardsCache[idx].buy_price = costVal; cardsCache[idx].tags = tags; } loadData(); filterVault(); loadOracle(); } }
        function exportCSV() { if (!cardsCache || cardsCache.length === 0) return showToast("No data to export.", "error"); const headers = ["Name", "Set", "Collector Number", "Quantity", "Buy Price", "Market Price", "Tags", "Last Updated"]; const rows = cardsCache.map(c => { const name = c.name ? `"${c.name.replace(/"/g, '""')}"` : '""'; const set = c.set_code || ""; const num = c.collector_number || ""; const qty = c.quantity || 0; const buy = c.buy_price || 0; const mkt = c.market_price_usd || 0; const tags = c.tags ? `"${c.tags.join(', ')}"` : '""'; const date = c.last_price_update || ""; return [name, set, num, qty, buy, mkt, tags, date].join(","); }); const csvContent = [headers.join(",")].concat(rows).join("\n"); const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement("a"); link.setAttribute("href", url); link.setAttribute("download", "grimoire_export.csv"); document.body.appendChild(link); link.click(); document.body.removeChild(link); showToast("Export successful!", "success"); }

        function parseDeckList(t) {
            const l = t.split('\n');
            let T = 0;
            const u = new Map();
            const r = /^(\d+)\s+(.+)/;
            l.forEach(x => {
                const m = x.trim().match(r);
                if (m) {
                    const q = parseInt(m[1]),
                        n = m[2].trim();
                    if (!isNaN(q)) {
                        T += q;
                        const k = n.toLowerCase().replace(/[^a-z0-9]/g, '');
                        u.set(k, {
                            qty: q,
                            name: n
                        })
                    }
                }
            });
            return {
                totalCount: T,
                cards: Array.from(u.values())
            };
        }
        
        // V5.6: New handler for the consolidated tools dropdown
        function handleDeckTool(action) {
            // Reset the dropdown immediately after selection
            document.getElementById('tools-dropdown').value = '';

            switch (action) {
                case 'edit':
                    showRitualEditor(true);
                    break;
                case 'view_toggle':
                    toggleDeckView();
                    break;
                case 'copy_missing':
                    copyMissing();
                    break;
                case 'buy':
                    buyDeck();
                    break;
                case 'print':
                    printProxies();
                    break;
                case 'export_arena':
                    exportArena();
                    break;
                case 'export_text':
                    exportDeck();
                    break;
                default:
                    return;
            }
        }


        async function loadDecks() {
            document.getElementById('deck-workspace').classList.add('hidden');
            document.getElementById('deck-library').classList.remove('hidden');
            const {
                data
            } = await sb.from('decks').select('*').order('updated_at', {
                ascending: false
            });
            const gridEl = document.getElementById('deck-grid-container');
            window.myDecks = data || [];
            let html = ` <div class="deck-card new-deck-card" onclick="showRitualEditor()"> <span style="font-size:30px; margin-bottom:10px;">‚ûï</span> <span style="font-weight:600;">Create New Deck</span> </div> `;
            if (data && data.length > 0) {
                html += data.map(d => {
                    const date = new Date(d.updated_at).toLocaleDateString();
                    const bgStyle = d.cover_url ? `background-image: url('${d.cover_url}');` : '';
                    return ` <div class="deck-card" onclick="viewRitualDetails('${d.id}')" style="${bgStyle}"> <div class="deck-card-content"> <div style="display:flex; justify-content:space-between; align-items:start;"> <h4>${d.name}</h4> <span style="color:var(--red); font-size:16px; padding:5px; margin:-5px -5px 0 0; cursor:pointer;" onclick="askDeleteDeck('${d.id}', event)">‚úï</span> </div> <div class="deck-card-meta"> <span>${d.card_count || 0} Cards</span> <span class="format-badge">${d.format || 'Casual'}</span> </div> </div> </div>`;
                }).join('');
            }
            gridEl.innerHTML = html;
        }

        function filterDecks() {
            const term = document.getElementById('deckSearch').value.toLowerCase();
            document.querySelectorAll('.deck-card').forEach(c => {
                if (c.classList.contains('new-deck-card')) return;
                c.style.display = c.innerText.toLowerCase().includes(term) ? 'flex' : 'none';
            });
        }

        async function setDeckCover(url) {
            if (!currentViewedDeckId) return showToast("Save decklist first.", "error");
            await sb.from('decks').update({
                cover_url: url
            }).eq('id', currentViewedDeckId);
            currentDeckCoverUrl = url;
            renderDeckVisuals();
            showToast("Cover art updated!", "success");
        }

        function exportDeck() {
            const main = document.getElementById('deckMain').value;
            const side = document.getElementById('deckSide').value;
            let exportText = main;
            if (side.trim().length > 0) {
                exportText += '\n\n// Sideboard\n' + side;
            }
            navigator.clipboard.writeText(exportText).then(() => {
                showToast("üìã Decklist exported (Text format) to clipboard!", "success");
            });
        }

        function exportArena() {
            if (!window.currentDeckCache || currentDeckCache.length === 0) {
                return showToast("Please validate the decklist first.", "error");
            }
            
            const lines = [];
            
            const commanderName = document.getElementById('deckCommander').value;
            if (commanderName && commanderName.trim().length > 0) {
                const commanderCard = currentDeckCache.find(c => c.name.toLowerCase() === commanderName.toLowerCase());
                if (commanderCard) {
                    lines.push(`1 ${commanderCard.name} (${commanderCard.set_code.toUpperCase()}) ${commanderCard.collector_number}`);
                }
            }

            currentDeckCache.forEach(card => {
                if (card.name.toLowerCase() !== commanderName.toLowerCase()) {
                    const line = `${card.quantity} ${card.name} (${card.set_code.toUpperCase()}) ${card.collector_number}`;
                    lines.push(line);
                }
            });

            const arenaExportText = lines.join('\n');

            navigator.clipboard.writeText(arenaExportText).then(() => {
                showToast("üéÆ Decklist exported (MTG Arena format) to clipboard!", "success");
            });
        }


        function printProxies() {
            if (!currentDeckCache || currentDeckCache.length === 0) return showToast("No cards to print!", "error");
            const printWindow = window.open('', '_blank');
            let html = `<html><head><title>Grimoire Proxy Sheet</title><style> body { margin: 0; padding: 10px; font-family: sans-serif; background: white; } .print-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; width: 7.44in; height: 10.4in; margin: 0 auto; } .card-wrapper { width: 2.48in; height: 3.46in; border-radius: 9px; overflow: hidden; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #333; text-align: center; } .card-img { width: 100%; height: 100%; object-fit: cover; } @media print { body { -webkit-print-color-adjust: exact; } .no-print { display: none; } } </style></head><body> <div class="no-print" style="text-align:center; padding:20px; background:#eee; margin-bottom:20px;"> <h2>üñ®Ô∏è The Artificer's Press</h2> <p>Press Ctrl+P (Cmd+P) to print. Ensure scale is 100%.</p> </div> <div class="print-grid">`;
            currentDeckCache.forEach(c => {
                for (let i = 0; i < c.quantity; i++) {
                    const imgUrl = getCardImage(c);
                    if (imgUrl) {
                        html += `<div class="card-wrapper"><img class="card-img" src="${imgUrl}" loading="eager" alt="${c.name}" onerror="this.style.display='none'; this.parentElement.innerText='${c.name}'"></div>`;
                    } else {
                        html += `<div class="card-wrapper">${c.name}</div>`;
                    }
                }
            });
            html += `</div></body></html>`;
            printWindow.document.write(html);
            printWindow.document.close();
        }

        // V5.0: DECK SAVE FUNCTION UPDATED
        async function saveDeck() {
            const name = document.getElementById('deckName').value;
            const commander = document.getElementById('deckCommander').value; 
            const main = document.getElementById('deckMain').value;
            const side = document.getElementById('deckSide').value;
            let fullList = main;
            if (side.trim().length > 0) fullList += '\n// Sideboard\n' + side;
            const format = document.getElementById('deckFormat').value;
            if (!name) return showToast("Name required", "error");
            const {
                totalCount,
                cards
            } = parseDeckList(fullList);
            let coverUrl = currentDeckCoverUrl || ''; // Use cached cover URL if it exists
            
            // --- Cover Art Resolution (Logic remains same) ---
            if (!coverUrl) { // Only fetch cover art if it's missing
                if (commander.trim().length > 0) {
                    try {
                        const res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(commander)}`);
                        const data = await res.json();
                        coverUrl = getCardImage(data);
                    } catch (e) {
                        // Fallback logic for cover if commander fails
                        if (cards.length > 0) {
                            try {
                                const res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cards[0].name)}`);
                                const data = await res.json();
                                coverUrl = getCardImage(data);
                            } catch (e2) {
                                console.log("Cover fetch failed for both commander and main card.");
                            }
                        }
                    }
                } else if (cards.length > 0) { 
                    const basicLands = ['plains', 'island', 'swamp', 'mountain', 'forest', 'wastes'];
                    let candidate = cards[0];
                    for (let c of cards) {
                        if (!basicLands.includes(c.name.toLowerCase())) {
                            candidate = c;
                            break;
                        }
                    }
                    try {
                        const res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(candidate.name)}`);
                        const data = await res.json();
                        coverUrl = getCardImage(data);
                    } catch (e) {
                        console.log("Cover fetch failed.");
                    }
                }
            }
            // --- End Cover Art Resolution ---
            
            let error;
            const deckData = {
                name,
                commander, 
                card_list: fullList,
                card_count: totalCount,
                format,
                cover_url: coverUrl,
                // V5.0: Include the structured list if it exists (only populated after validation)
                structured_list: window.currentDeckStructuredList || null 
            };

            if (currentViewedDeckId) {
                const res = await sb.from('decks').update(deckData).eq('id', currentViewedDeckId);
                error = res.error;
            } else {
                const res = await sb.from('decks').insert({ user_id: session.user.id, ...deckData });
                error = res.error;
            }

            if (!error) {
                showToast(`üíæ Decklist '${name}' saved!`, "success");
                loadDecks();
            } else {
                showToast(error.message, "error");
            }
        }

        // V5.1: Updated to load structured list if present
        function viewRitualDetails(id) {
            document.getElementById('deck-library').classList.add('hidden');
            document.getElementById('deck-workspace').classList.remove('hidden');
            currentViewedDeckId = id;
            const d = window.myDecks.find(x => x.id == id);
            if (!d) return showToast("Decklist not found in local cache.", "error");
            
            document.getElementById('deckName').value = d.name;
            document.getElementById('deckCommander').value = d.commander || ''; 
            document.getElementById('detail-commander').innerText = d.commander ? `üëë Commander: ${d.commander}` : ''; 
            
            const parts = (d.card_list || '').split('// Sideboard');
            document.getElementById('deckMain').value = parts[0].trim();
            document.getElementById('deckSide').value = parts[1] ? parts[1].trim() : '';
            document.getElementById('deckFormat').value = d.format || 'Casual';
            currentDeckCoverUrl = d.cover_url;
            
            // V5.1: Use structured list data if it exists, otherwise clear cache and run validation
            if (d.structured_list && d.structured_list.length > 0) {
                 window.currentDeckStructuredList = d.structured_list;
            } else {
                 window.currentDeckStructuredList = null;
            }
            validateDeck();
        }

        function showRitualEditor(keepData = false) {
            document.getElementById('deck-library').classList.add('hidden');
            document.getElementById('deck-workspace').classList.remove('hidden');
            document.getElementById('detail-mode').classList.add('hidden');
            document.getElementById('editor-mode').classList.remove('hidden');
            clearCharts();
            currentViewedDeckId = null;
            window.currentDeckStructuredList = null; // Clear structured list when opening editor
            if (!keepData) {
                document.getElementById('deckName').value = '';
                document.getElementById('deckCommander').value = ''; 
                document.getElementById('deckMain').value = '';
                document.getElementById('deckSide').value = '';
            }
        }

        // V5.1: Ownership Analysis updated to use structured data
        function analyzeOwnership(t) { 
            // V5.1: Use the global vaultLookup map populated in loadData()
            
            const lines = t.split('\n');
            let html = '';
            let totalCards = 0;
            let totalOwned = 0;
            const regex = /^(\d+)\s+(.+)/;
            
            // --- V5.1: Check if structured data exists (meaning it was recently validated/saved) ---
            if (window.currentDeckStructuredList && window.currentDeckStructuredList.length > 0) {
                const structuredHtml = window.currentDeckStructuredList.map(c => {
                    const qtyNeeded = c.qty;
                    // V5.1: Create the lookup key based on structured card data
                    const lookupKey = `${c.name.toLowerCase().trim()}_${c.set}_${c.num}`;
                    let qtyOwned = vaultLookup[lookupKey] || 0;
                    
                    // Simple basic land check (assuming basic lands are always owned)
                    const isBasicLand = ['plains', 'island', 'swamp', 'mountain', 'forest'].some(name => c.name.toLowerCase().includes(name));

                    if (isBasicLand) {
                        qtyOwned = qtyNeeded;
                    }

                    const ownedForThisLine = Math.min(qtyOwned, qtyNeeded);
                    totalCards += qtyNeeded;
                    totalOwned += ownedForThisLine;
                    
                    let statusClass = 'is-missing';
                    if (qtyOwned >= qtyNeeded) statusClass = 'is-owned';
                    else if (qtyOwned > 0) statusClass = 'is-partial';
                    
                    return `<div class="deck-line ${statusClass}" data-qty-needed="${qtyNeeded}" data-qty-owned="${qtyOwned}" data-name="${c.name}"><strong>${qtyNeeded}</strong> ${c.name} <span style="float:right; font-size:10px; opacity:0.7;">(Own: ${qtyOwned})</span></div>`;
                }).join('');
                
                html = structuredHtml;
                
            } else {
                // --- Fallback to simple name matching (pre-V5.0 logic) if no structured data is available ---
                const vaultMapFallback = {};
                cardsCache.forEach(c => { vaultMapFallback[c.name.toLowerCase().trim()] = (vaultMapFallback[c.name.toLowerCase().trim()] || 0) + c.quantity; });
                
                lines.forEach(line => {
                    const match = line.trim().match(regex);
                    if (match) {
                        const qtyNeeded = parseInt(match[1]);
                        const name = match[2].trim();
                        const key = name.toLowerCase();
                        let qtyOwned = 0;
                        
                        // Simple Basic Land Check (fallback mode)
                        const isBasicLand = ['plains', 'island', 'swamp', 'mountain', 'forest'].some(n => key.includes(n));
                        
                        if (isBasicLand) {
                           qtyOwned = qtyNeeded; // Assume owned if basic land in fallback mode
                        } else {
                           qtyOwned = vaultMapFallback[key] || 0;
                        }

                        const ownedForThisLine = Math.min(qtyOwned, qtyNeeded);
                        totalCards += qtyNeeded;
                        totalOwned += ownedForThisLine;
                        
                        let statusClass = 'is-missing';
                        if (qtyOwned >= qtyNeeded) statusClass = 'is-owned';
                        else if (qtyOwned > 0) statusClass = 'is-partial';
                        
                        html += `<div class="deck-line ${statusClass}" data-qty-needed="${qtyNeeded}" data-qty-owned="${qtyOwned}" data-name="${name}"><strong>${qtyNeeded}</strong> ${name} <span style="float:right; font-size:10px; opacity:0.7;">(Own: ${qtyOwned})</span></div>`;
                    } else if (line.trim().length > 0) {
                        html += `<div class="deck-line" style="opacity:0.5; font-size:11px;">${line}</div>`;
                    }
                });
            }

            const percent = totalCards > 0 ? Math.round((totalOwned / totalCards) * 100) : 0;
            const viewer = document.getElementById('detail-decklist-viewer');
            viewer.innerHTML = html;
            viewer.classList.remove('hidden');
            document.getElementById('detail-owned-percent').innerText = `${percent}%`;
            document.getElementById('detail-owned-bar').style.width = `${percent}%`;
            const bar = document.getElementById('detail-owned-bar');
            if (percent === 100) bar.style.backgroundColor = 'var(--green)';
            else if (percent > 50) bar.style.backgroundColor = 'var(--primary)';
            else bar.style.backgroundColor = 'var(--red)';
        }

        // V5.0 + V5.5: DECK VALIDATION FUNCTION UPDATED (includes structured list creation & image display)
        async function validateDeck() {
            const name = document.getElementById('deckName').value;
            const commander = document.getElementById('deckCommander').value; 
            const format = document.getElementById('deckFormat').value; 
            const main = document.getElementById('deckMain').value;
            const side = document.getElementById('deckSide').value;
            const listText = main + '\n' + side;
            const resultsEl = document.getElementById('detail-analysis-results');
            const btn = document.getElementById('validateDeckBtn');
            
            if (!listText.trim() && !commander.trim()) return showToast("Decklist is empty.", "error");

            document.getElementById('deck-library').classList.add('hidden');
            document.getElementById('deck-workspace').classList.remove('hidden');
            document.getElementById('editor-mode').classList.add('hidden');
            document.getElementById('detail-mode').classList.remove('hidden');
            document.getElementById('detail-deck-name').innerText = document.getElementById('deckName').value || "New Decklist";
            document.getElementById('detail-commander').innerText = commander.trim() ? `üëë Commander: ${commander}` : ''; 
            document.getElementById('detail-decklist-viewer').classList.remove('hidden');
            document.getElementById('detail-visual-grid').classList.add('hidden');
            
            // Analyze Ownership will run again later using the structured list if found, but run once now for quick UI update.
            analyzeOwnership(listText);
            
            // If the structured list already exists, skip API calls and just run stats/render
            if (window.currentDeckStructuredList && window.currentDeckStructuredList.length > 0) {
                 allMatchedCards = window.currentDeckStructuredList;
                 // Rebuild stats and render everything without hitting Scryfall again
                 processDeckData(allMatchedCards, commander, format, resultsEl);
                 if (btn) { btn.innerText = "‚úÖ Validation Skipped"; btn.disabled = false; }
                 return;
            }

            // --- API RESOLUTION START ---
            resultsEl.innerHTML = `<p style="color:var(--subtext);">Processing decklist...</p>`;
            if (btn) {
                btn.innerText = "Resolving...";
                btn.disabled = true;
            }

            const {
                totalCount,
                cards: parsedCards
            } = parseDeckList(listText);

            const cardsToResolve = [...parsedCards];
            if (commander.trim()) {
                cardsToResolve.push({ qty: 1, name: commander }); 
            }

            if (cardsToResolve.length === 0) {
                if (btn) {
                    btn.innerText = "‚úÖ Validate & Resolve Decklist";
                    btn.disabled = false;
                }
                resultsEl.innerHTML = '<p style="color:var(--red);">No valid card lines found.</p>';
                return showToast("No valid decklist lines found.", "error");
            }

            const identifiers = cardsToResolve.map(c => ({
                name: c.name
            }));
            const chunkSize = 75;
            const totalChunks = Math.ceil(identifiers.length / chunkSize);
            let allMatchedCards = [];
            let allUnmatched = [];

            try {
                for (let i = 0; i < totalChunks; i++) {
                    const chunk = identifiers.slice(i * chunkSize, (i + 1) * chunkSize);
                    const response = await fetch('https://api.scryfall.com/cards/collection', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            identifiers: chunk
                        })
                    });
                    const data = await response.json();
                    if (data.object === 'error' && !data.data) throw new Error(data.details);
                    allMatchedCards = allMatchedCards.concat(data.data);
                    if (data.not_found) allUnmatched = allUnmatched.concat(data.not_found);
                }
                
                processDeckData(allMatchedCards, commander, format, resultsEl, parsedCards, allUnmatched);

            } catch (error) {
                resultsEl.innerHTML = `<p style="color:var(--red);">Error: ${error.message}</p>`;
                showToast("Validation Error.", "error");
            } finally {
                if (btn) {
                    btn.innerText = "‚úÖ Validate & Resolve Decklist";
                    btn.disabled = false;
                }
            }
        }
        
        // V5.0 CORE FUNCTION: Separated logic to run after API call or after loading structured list
        function processDeckData(matchedCards, commander, format, resultsEl, parsedCards = [], allUnmatched = []) {
            
            let legalityErrors = []; 
            let identityErrors = []; 
            let commanderCardData = null; 
            let commanderColors = []; 
            let structuredDeck = []; 
            
            // --- COMMANDER AND LEGALITY CHECKS ---
            const formatKey = format.toLowerCase().replace(/[^a-z]/g, '');
            document.getElementById('detail-commander-img').style.display = 'none';

            // Find Commander Data
            if (commander.trim()) {
                commanderCardData = matchedCards.find(c => c.name.toLowerCase() === commander.toLowerCase());
                if (commanderCardData) {
                    commanderColors = commanderCardData.color_identity || []; 
                    // V5.5: Display Commander Image
                    document.getElementById('detail-commander-img').src = getCardImage(commanderCardData);
                    document.getElementById('detail-commander-img').style.display = 'block';
                    
                    matchedCards = matchedCards.filter(c => c.name.toLowerCase() !== commander.toLowerCase());
                } 
            }
            
            // 1. Commander Legality Check
            if (commanderCardData) {
                const legalityStatus = commanderCardData.legalities?.[formatKey];
                const isLegalCommander = format === 'Commander' ? legalityStatus === 'commander' : true; 
                
                if (legalityStatus === 'banned' || legalityStatus === 'not_legal' || (format === 'Commander' && !isLegalCommander)) {
                    legalityErrors.push({
                        name: commanderCardData.name + (format === 'Commander' ? " (Commander)" : ""),
                        status: legalityStatus || 'Not Legal',
                        format: format,
                        qty: 1
                    });
                }
            }
            
            // 2. Deck Card Legality and Color Identity Check & STRUCTURED LIST BUILD
            const totalCount = parsedCards.reduce((sum, c) => sum + c.qty, 0) + (commander.trim() ? 1 : 0);

            let totalDeckPrice = 0;
            window.currentDeckStats = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };
            currentDeckCache = [];
            const typeAgg = {};
            const cmcAgg = {};

            matchedCards.forEach(cardData => {
                const deckCard = parsedCards.find(c => c.name.toLowerCase() === cardData.name.toLowerCase());
                if (!deckCard) return; 

                const quantity = deckCard.qty;
                currentDeckCache.push({ ...cardData, quantity: quantity });
                
                // V5.0: Build Structured List Entry
                structuredDeck.push({
                    name: cardData.name,
                    qty: quantity,
                    set: cardData.set,
                    num: cardData.collector_number,
                    img: getCardImage(cardData),
                    type: cardData.type_line,
                    cmc: cardData.cmc || 0,
                    identity: cardData.color_identity || [],
                    price: parseFloat(cardData.prices.usd || cardData.prices.usd_foil || 0)
                });
                
                // --- STATS AGGREGATION (for Charts) ---
                const primaryType = cardData.type_line ? cardData.type_line.split('‚Äî')[0].split(' ')[0].trim() : 'Unknown';
                typeAgg[primaryType] = (typeAgg[primaryType] || 0) + quantity;
                if (!cardData.type_line.toLowerCase().includes('land')) {
                    const cmc = Math.floor(cardData.cmc || 0);
                    cmcAgg[cmc] = (cmcAgg[cmc] || 0) + quantity;
                }
                const price = parseFloat(cardData.prices.usd || cardData.prices.usd_foil || 0);
                totalDeckPrice += (price * quantity);
                if (cardData.mana_cost) {
                    const cost = cardData.mana_cost;
                    window.currentDeckStats['W'] += (cost.match(/{W}/g) || []).length * quantity;
                    window.currentDeckStats['U'] += (cost.match(/{U}/g) || []).length * quantity;
                    window.currentDeckStats['B'] += (cost.match(/{B}/g) || []).length * quantity;
                    window.currentDeckStats['R'] += (cost.match(/{R}/g) || []).length * quantity;
                    window.currentDeckStats['G'] += (cost.match(/{G}/g) || []).length * quantity;
                    window.currentDeckStats['C'] += (cost.match(/{C}/g) || []).length * quantity;
                }
                
                // Legality Check (V4.0.1)
                const legalityStatus = cardData.legalities?.[formatKey];
                if (legalityStatus === 'banned' || legalityStatus === 'not_legal') {
                    legalityErrors.push({
                        name: cardData.name,
                        status: legalityStatus,
                        format: format,
                        qty: deckCard.qty
                    });
                }
                
                // Color Identity Check (V4.0.1)
                if (format === 'Commander' && commanderColors.length > 0) {
                    const cardIdentity = cardData.color_identity || [];
                    const isOutsideIdentity = cardIdentity.some(color => !commanderColors.includes(color));

                    if (isOutsideIdentity) {
                        identityErrors.push({
                            name: cardData.name,
                            qty: deckCard.qty,
                            colors: cardIdentity.join(' ')
                        });
                    }
                }
            });

            document.getElementById('detail-deck-price').innerText = `$${totalDeckPrice.toFixed(2)}`;

            // V5.0: Store structured data globally
            window.currentDeckStructuredList = structuredDeck;

            // Rerun ownership analysis (V5.1) using the new structured list
            analyzeOwnership(document.getElementById('deckMain').value + '\n' + document.getElementById('deckSide').value);


            // --- RENDER RESULTS ---
            let output = `<p style="color:var(--green); font-weight: 600;">‚úÖ Resolution Complete! Total Cards: ${totalCount}</p>`;
            output += `<p>Format Selected: <strong>${format}</strong>`;
            
            if (format === 'Commander' && commanderColors.length > 0) {
                const colorPips = commanderColors.map(c => {
                    const colorClass = `pip-${c.toLowerCase()}`;
                    return `<span class="mana-pip ${colorClass}"></span>`;
                }).join('');
                output += `<br><span style="font-size:12px; color:var(--subtext);">Identity: ${colorPips}</span>`;
            }
            output += `</p>`;


            if (legalityErrors.length > 0) {
                output += `<p style="color:var(--red); font-weight: 600;">‚ö†Ô∏è ${legalityErrors.length} Cards Illegal in ${format}:</p><ul>`;
                legalityErrors.forEach(e => {
                    const status = e.status === 'banned' ? 'BANNED' : (e.status === 'not_legal' ? 'Not Legal' : 'Illegal Slot');
                    output += `<li style="margin-left: -20px;">* ${e.qty}x ${e.name} (<strong style="color:var(--red);">${status}</strong>)</li>`;
                });
                output += `</ul>`;
                showToast(`Decklist is illegal in ${format}.`, "error");
            }
            
            if (identityErrors.length > 0) {
                output += `<p style="color:var(--red); font-weight: 600;">üö´ ${identityErrors.length} Cards Outside Color Identity:</p><ul>`;
                identityErrors.forEach(e => {
                    output += `<li style="margin-left: -20px;">* ${e.qty}x ${e.name} (Colors: ${e.colors})</li>`;
                });
                output += `</ul>`;
                showToast(`Decklist violates Commander Color Identity.`, "error");
            }


            if (allUnmatched.length > 0) {
                output += `<p style="color:var(--yellow); font-weight: 600;">‚ö†Ô∏è ${allUnmatched.length} Card Names Unmatched (Typo?):</p><ul>`;
                allUnmatched.forEach(u => output += `<li style="margin-left: -20px;">* ${u.name || 'Unknown'}</li>`);
                output += `</ul>`;
                if (legalityErrors.length === 0 && identityErrors.length === 0) showToast(`Validation complete with ${allUnmatched.length} unmatched names.`, "info");
            }

            if (legalityErrors.length === 0 && identityErrors.length === 0 && allUnmatched.length === 0) {
                output += `<p style="color:var(--green);">All cards resolved and legal in ${format}!</p>`;
                showToast(`Decklist successfully resolved!`, "success");
            }

            resultsEl.innerHTML = output;

            if (allUnmatched.length === 0) {
                document.getElementById('deck-charts').classList.remove('hidden');
                renderTypeChart(typeAgg);
                renderManaCurve(cmcAgg);
                renderColorChart(window.currentDeckStats);
            }
        }
        
        function toggleDeckView() {
            const textView = document.getElementById('detail-decklist-viewer');
            const visualView = document.getElementById('detail-visual-grid');
            if (textView.classList.contains('hidden')) {
                // V5.0: Use structured list data if available, otherwise fallback to parsing text
                if (window.currentDeckStructuredList && window.currentDeckStructuredList.length > 0) {
                     renderDeckVisuals(window.currentDeckStructuredList);
                } else if (currentDeckCache.length === 0) {
                     return showToast("Resolve decklist first to see visuals.", "error");
                }
                textView.classList.add('hidden');
                visualView.classList.remove('hidden');
            } else {
                textView.classList.remove('hidden');
                visualView.classList.add('hidden');
            }
        }

        // V5.0: Render visuals directly from the structured list
        function renderDeckVisuals(structuredList = currentDeckCache) {
            const container = document.getElementById('detail-visual-grid');
            container.innerHTML = '';
            const groups = {};
            
            structuredList.forEach(card => {
                const type = card.type ? card.type.split('‚Äî')[0].trim() : (card.type_line ? card.type_line.split('‚Äî')[0].trim() : 'Unknown');
                if (!groups[type]) groups[type] = [];
                groups[type].push(card);
            });
            
            const typeOrder = ["Creature", "Planeswalker", "Instant", "Sorcery", "Artifact", "Enchantment", "Land"];
            typeOrder.forEach(type => {
                if (groups[type]) {
                    renderSection(container, type, groups[type]);
                    delete groups[type];
                }
            });
            for (const type in groups) {
                renderSection(container, type, groups[type]);
            }
        }


        function renderSection(container, title, cards) {
            const section = document.createElement('div');
            section.className = 'visual-section';
            const count = cards.reduce((a, c) => a + c.qty, 0); // Use .qty from structured list
            section.innerHTML = `<div class="visual-header">${title} (${count})</div>`;
            const grid = document.createElement('div');
            grid.className = 'visual-card-grid';
            cards.forEach(card => {
                const imgUrl = card.img || getCardImage(card); // Use .img from structured list
                const price = card.price || card.prices.usd || card.prices.usd_foil || 'N/A';
                const isCover = (currentDeckCoverUrl === imgUrl);
                const activeClass = isCover ? 'is-cover-card' : '';
                const starColor = isCover ? 'var(--yellow)' : 'var(--subtext)';
                const item = document.createElement('div');
                item.className = `visual-card ${activeClass}`;
                item.innerHTML = ` <button class="cover-btn" style="color:${starColor}" onclick="setDeckCover('${imgUrl}'); event.stopPropagation();">‚òÖ</button> <img src="${imgUrl}" loading="lazy" onclick="openCodex('${card.set || card.set_code}', '${card.num || card.collector_number}')"> <div class="visual-badge">${card.qty || card.quantity}x</div> `;
                item.title = `${card.name} ($${price})`;
                grid.appendChild(item);
            });
            section.appendChild(grid);
            container.appendChild(section);
        }

        // V5.3: Updated to iterate over HTML elements for current ownership status
        function copyMissing() {
            const missingLines = [];
            
            // Iterate over all list lines in the detailed viewer
            document.querySelectorAll('#detail-decklist-viewer .deck-line').forEach(el => {
                const needed = parseInt(el.getAttribute('data-qty-needed'));
                const owned = parseInt(el.getAttribute('data-qty-owned'));
                const name = el.getAttribute('data-name');
                const toBuy = needed - owned;
                
                if (toBuy > 0) {
                    missingLines.push(`${toBuy} ${name}`);
                }
            });
            
            if (missingLines.length === 0) return showToast("You own all these cards! Nothing to copy.", "success");
            
            navigator.clipboard.writeText(missingLines.join('\n')).then(() => {
                showToast(`üìã ${missingLines.length} missing card lines copied to clipboard!`, "success");
            }).catch(() => showToast("Failed to copy missing cards list.", "error"));
        }

        // V5.3: Updated to iterate over HTML elements for current ownership status
        function buyDeck() {
            const buyLines = [];
            
            // Iterate over all list lines in the detailed viewer
            document.querySelectorAll('#detail-decklist-viewer .deck-line').forEach(el => {
                const needed = parseInt(el.getAttribute('data-qty-needed'));
                const owned = parseInt(el.getAttribute('data-qty-owned'));
                const name = el.getAttribute('data-name');
                const toBuy = needed - owned;
                
                if (toBuy > 0) {
                    // Format for TCGPlayer Mass Entry: Qty Name 
                    buyLines.push(`${toBuy} ${name}`);
                }
            });
            
            if (buyLines.length === 0) return showToast("You own all these cards! Nothing to buy.", "success");
            
            // TCGPlayer mass entry format uses || as a separator
            const queryParam = buyLines.join('||');
            
            const url = `https://www.tcgplayer.com/massentry?c=${encodeURIComponent(queryParam)}&utm_source=TheGrimoire&utm_medium=decklist&utm_campaign=affiliate`;
            
            window.open(url, '_blank');
            showToast("üõí Opening TCGPlayer Mass Entry for missing cards.", "info");
        }

        function clearCharts() {
            if (typeChartInstance) {
                typeChartInstance.destroy();
                typeChartInstance = null;
            }
            if (manaCurveInstance) {
                manaCurveInstance.destroy();
                manaCurveInstance = null;
            }
            if (colorChartInstance) {
                colorChartInstance.destroy();
                colorChartInstance = null;
            }
            // Removed priceChartInstance clean up V5.1
            document.getElementById('deck-charts').classList.add('hidden');
        }

        function renderTypeChart(typeData) {
            if (typeChartInstance) typeChartInstance.destroy();
            const ctx = document.getElementById('typeChart').getContext('2d');
            typeChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(typeData),
                    datasets: [{
                        data: Object.values(typeData),
                        backgroundColor: CHART_COLORS,
                        borderColor: 'rgba(0, 0, 0, 0.4)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#a1a1aa'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Card Type Breakdown',
                            color: 'white'
                        }
                    }
                }
            });
        }

        function renderManaCurve(cmcData) {
            if (manaCurveInstance) manaCurveInstance.destroy();
            const ctx = document.getElementById('manaCurve').getContext('2d');
            const maxCmc = Math.max(...Object.keys(cmcData).map(Number));
            const labels = [];
            const data = [];
            for (let i = 0; i <= Math.min(maxCmc, 6); i++) {
                labels.push(i.toString());
                data.push(cmcData[i] || 0);
            }
            let cmcSevenPlus = 0;
            for (let i = 7; i <= maxCmc; i++) {
                cmcSevenPlus += (cmcData[i] || 0);
            }
            if (maxCmc >= 7 || maxCmc === 0) {
                labels.push('7+');
                data.push(cmcSevenPlus);
            }
            manaCurveInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Card Count',
                        data: data,
                        backgroundColor: '#a78bfa',
                        borderColor: 'rgba(167, 139, 250, 0.2)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Mana Value (CMC) Curve',
                            color: 'white'
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#a1a1aa'
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.05)'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#a1a1aa',
                                stepSize: 1
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.05)'
                            }
                        }
                    }
                }
            });
        }

        function renderColorChart(colors) {
            if (colorChartInstance) colorChartInstance.destroy();
            const ctx = document.getElementById('colorChart').getContext('2d');
            const colorLabels = ['White', 'Blue', 'Black', 'Red', 'Green', 'Colorless'];
            const colorData = [colors['W'] || 0, colors['U'] || 0, colors['B'] || 0, colors['R'] || 0, colors['G'] || 0, colors['C'] || 0];
            const bgColors = ['#f0f2c0', '#b3ceea', '#a69f9d', '#ea9f82', '#c4d3ca', '#d8d8d8'];
            colorChartInstance = new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: colorLabels,
                    datasets: [{
                        data: colorData,
                        backgroundColor: bgColors,
                        borderColor: 'rgba(0,0,0,0.5)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#a1a1aa'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Mana Symbol Breakdown',
                            color: 'white'
                        }
                    },
                    scales: {
                        r: {
                            ticks: {
                                display: false
                            },
                            grid: {
                                color: 'rgba(255,255,255,0.1)'
                            }
                        }
                    }
                }
            });
        }

        // REMOVED V5.1: Price History Chart Render (Stabilization)
        
        // --- BATTLEFIELD (V3.0.0) ---
        function initBattlefield() {
            if (!currentDeckCache.length) return showToast("Resolve decklist first!", "error");
            document.getElementById('view-decks').classList.add('hidden');
            document.getElementById('view-battlefield').classList.remove('hidden');
            document.querySelector('.sidebar').style.display = window.innerWidth <= 768 ? 'none' : 'flex';

            gameState = {
                lib: [],
                hand: [],
                field: [],
                grave: [],
                exile: [],
                life: 20,
                turn: 1
            };
            currentDeckCache.forEach(c => {
                for (let i = 0; i < c.quantity; i++) gameState.lib.push({
                    uid: Math.random().toString(36),
                    ...c,
                    tapped: false
                });
            });
            for (let i = gameState.lib.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.lib[i], gameState.lib[j]] = [gameState.lib[j], gameState.lib[i]];
            }
            for (let i = 0; i < 7; i++) gameState.hand.push(gameState.lib.pop());
            renderBF();
            showToast("Hotkeys: D=Draw, U=Untap, L=Life");
        }

        function createToken() {
            const name = prompt("Token Name (e.g. Soldier):", "Token");
            if (name) {
                gameState.field.push({
                    uid: Math.random().toString(36),
                    name: name,
                    type_line: 'Token',
                    tapped: false,
                    isToken: true
                });
                renderBF();
            }
        }

        function renderBF() {
            document.getElementById('bf-life').innerText = gameState.life;
            document.getElementById('bf-turn').innerText = gameState.turn;
            document.getElementById('bf-lib-count').innerText = gameState.lib.length;
            document.getElementById('bf-grave-count').innerText = gameState.grave.length;
            document.getElementById('bf-exile-count').innerText = gameState.exile.length;
            document.getElementById('bf-hand').innerHTML = gameState.hand.map(c => `<div class="bf-card" onclick="playCard('${c.uid}')"><img src="${getCardImage(c)}"></div>`).join('');
            const cardHTML = (c) => {
                const img = c.isToken ? `<div class="token-card" style="width:100%; height:100%; border-radius:8px;">${c.name}</div>` : `<img src="${getCardImage(c)}">`;
                const counters = c.counters ? `<div class="counter-badge" onclick="event.stopPropagation(); addCounter('${c.uid}', 1)" oncontextmenu="event.preventDefault(); event.stopPropagation(); addCounter('${c.uid}', -1)">${c.counters}</div>` : `<div class="counter-badge" onclick="event.stopPropagation(); addCounter('${c.uid}', 1)" style="opacity:0.3; background:black;">+</div>`;
                return `<div class="bf-card ${c.tapped?'bf-tapped':''}" onclick="tapCard('${c.uid}')" oncontextmenu="killCard('${c.uid}',event)"><div class="tap-icon">‚§µ</div>${counters}${img}</div>`;
            };
            const front = gameState.field.filter(c => !c.type_line.includes('Land') || c.isToken);
            const back = gameState.field.filter(c => c.type_line.includes('Land') && !c.isToken);
            document.getElementById('bf-frontline').innerHTML = '<div class="bf-row-label">Combat / Spells</div>' + front.map(cardHTML).join('');
            document.getElementById('bf-backline').innerHTML = '<div class="bf-row-label">Lands / Mana</div>' + back.map(cardHTML).join('');
        }

        function drawCard() {
            if (gameState.lib.length) gameState.hand.push(gameState.lib.pop());
            renderBF();
        }

        function playCard(uid) {
            const i = gameState.hand.findIndex(c => c.uid === uid);
            if (i > -1) gameState.field.push(gameState.hand.splice(i, 1)[0]);
            renderBF();
        }

        function tapCard(uid) {
            const c = gameState.field.find(c => c.uid === uid);
            if (c) c.tapped = !c.tapped;
            renderBF();
        }

        function addCounter(uid, n) {
            const c = gameState.field.find(c => c.uid === uid);
            if (c) {
                c.counters = (c.counters || 0) + n;
                if (c.counters <= 0) delete c.counters;
                renderBF();
            }
        }

        function killCard(uid, e) {
            e.preventDefault();
            const i = gameState.field.findIndex(c => c.uid === uid);
            if (i > -1) {
                const c = gameState.field.splice(i, 1)[0];
                c.tapped = false;
                c.counters = 0;
                gameState.grave.push(c);
            }
            renderBF();
        }

        function nextTurn() {
            gameState.turn++;
            gameState.field.forEach(c => c.tapped = false);
            drawCard();
            showToast("Untap, Upkeep, Draw.");
        }

        function updateLife(n) {
            gameState.life += n;
            renderBF();
        }

        function exitBattlefield() {
            document.getElementById('view-battlefield').classList.add('hidden');
            document.getElementById('view-decks').classList.remove('hidden');
            document.querySelector('.sidebar').style.display = window.innerWidth <= 768 ? 'none' : 'flex';
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('view-battlefield').classList.contains('hidden')) return;
            if (e.key === 'd' || e.key === 'D') drawCard();
            if (e.key === 'u' || e.key === 'U') {
                gameState.field.forEach(c => c.tapped = false);
                renderBF();
                showToast("All Untapped");
            }
            if (e.key === 'l') updateLife(1);
            if (e.key === 'L') updateLife(-1);
        });

        // V3.3.0 GEOMANCER (MANA CALCULATOR)
        function openLandCalculator() {
            if(!window.currentDeckStats) return showToast("Resolve decklist first.", "error");
            document.getElementById('land-modal').classList.remove('hidden');
            recalcLands();
        }
        function recalcLands() {
            const target = parseInt(document.getElementById('target-land-count').value) || 24;
            const stats = window.currentDeckStats;
            const totalPips = stats.W + stats.U + stats.B + stats.R + stats.G;
            if(totalPips === 0) { document.getElementById('land-results').innerHTML = "<p style='color:var(--subtext)'>No colored symbols found in Mainboard.</p>"; return; }
            suggestedLands = [];
            const lands = [
                { type: 'Plains', pips: stats.W, color: 'pip-w' },
                { type: 'Island', pips: stats.U, color: 'pip-u' },
                { type: 'Swamp', pips: stats.B, color: 'pip-b' },
                { type: 'Mountain', pips: stats.R, color: 'pip-r' },
                { type: 'Forest', pips: stats.G, color: 'pip-g' }
            ];
            let html = '';
            lands.forEach(l => {
                if(l.pips > 0) {
                    const count = Math.round((l.pips / totalPips) * target);
                    if(count > 0) {
                        suggestedLands.push({ name: l.type, qty: count });
                        html += `<div class="mana-row"> <div><span class="mana-pip ${l.color}"></span> ${l.type}</div> <div style="font-weight:700;">${count}</div> </div>`;
                    }
                }
            });
            document.getElementById('land-results').innerHTML = html;
        }
        function applyLands() {
            if(suggestedLands.length === 0) return;
            const mainInput = document.getElementById('deckMain');
            let currentText = mainInput.value.trim();
            if(currentText.length > 0) currentText += '\n';
            suggestedLands.forEach(l => { currentText += `${l.qty} ${l.name}\n`; });
            mainInput.value = currentText;
            document.getElementById('land-modal').classList.add('hidden');
            showToast("Lands added to decklist. Click Validate to resolve.", "success");
        }

        sb.auth.getSession().then(({
            data: {
                session: s
            }
        }) => {
            if (s) {
                session = s;
                document.getElementById('auth-screen').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('user-email').innerText = s.user.email;
                loadData();
            }
        });
    </script>
</body>
</html>

<script>
        // --- CONFIGURATION ---
        const SUPABASE_URL="https://mdirqlntcxqkthbwubmj.supabase.co";
        const SUPABASE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1kaXJxbG50Y3hxa3RoYnd1Ym1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2OTUyOTAsImV4cCI6MjA4MTI3MTI5MH0.XBhYZiwINycA-QjAH-cL4vFzzyppm1c4M322jNDmbvE";
        const sb=supabase.createClient(SUPABASE_URL,SUPABASE_KEY);
        
        const EMAILJS_SERVICE_ID = 'service_n9utr47';
        const EMAILJS_TEMPLATE_ID = 'template_xtth5gu';
        const EMAILJS_PUBLIC_KEY = 'ohGLAW9gp3OUPH0uf';

        // --- GLOBAL STATE ---
        let vaultLookup = {};
        let typeChartInstance = null, manaCurveInstance = null, colorChartInstance = null, editorChartInstance = null;
        let session=null, tempCardData=null, allVersions=[], searchTimer, cardsCache=[];
        let currentViewedDeckId=null, isResetMode=false;
        let currentDeckCache=[], currentDeckCoverUrl='';
        let currentDeckStructuredList = null;
        let vaultViewMode = localStorage.getItem('grimoire_view') || 'grid';
        const CHART_COLORS=['#a78bfa','#dc2626','#a78bfa','#4f46e5','#059669','#737373','#facc15'];
        let suggestedLands = [];
        let gameState = { lib: [], hand: [], field: [], grave: [], exile: [], life: 20, turn: 1 };
        let customTags = JSON.parse(localStorage.getItem('grimoire_custom_tags')) || ['Foil', 'Trade', 'Damaged', 'Signed'];

        // --- V9.3: THE GUARD (Button Safety) ---
        function setLoading(btn, isLoading) {
            if (!btn) return;
            if (isLoading) {
                btn.classList.add('btn-loading');
                btn.dataset.originalText = btn.innerText; 
            } else {
                btn.classList.remove('btn-loading');
            }
        }

        // --- UTILITIES ---
        function openUserOptionsModal() { document.getElementById('user-options-modal').classList.remove('hidden'); }
        function closeUserOptionsModal() { document.getElementById('user-options-modal').classList.add('hidden'); }
        
        function savePrefs() { 
            localStorage.setItem('grimoire_view', vaultViewMode); 
            localStorage.setItem('grimoire_sort', document.getElementById('vaultSort').value); 
            if (document.getElementById('settingsPriceSource')) localStorage.setItem('grimoire_default_price_source', document.getElementById('settingsPriceSource').value);
            if (document.getElementById('priceSource')) document.getElementById('priceSource').value = localStorage.getItem('grimoire_default_price_source') || 'usd';
            if (document.getElementById('settingsDefaultQty')) localStorage.setItem('grimoire_default_qty', document.getElementById('settingsDefaultQty').value);
            showToast("Preferences saved!", "success");
        }

        function loadPrefs() { 
            const defaultPriceSource = localStorage.getItem('grimoire_default_price_source') || 'usd';
            const defaultQty = localStorage.getItem('grimoire_default_qty') || '1';
            if(localStorage.getItem('grimoire_sort') && document.getElementById('vaultSort')) document.getElementById('vaultSort').value = localStorage.getItem('grimoire_sort'); 
            if(document.getElementById('priceSource')) document.getElementById('priceSource').value = defaultPriceSource;
            if(document.getElementById('settingsPriceSource')) document.getElementById('settingsPriceSource').value = defaultPriceSource;
            if(document.getElementById('settingsDefaultQty')) document.getElementById('settingsDefaultQty').value = defaultQty;
            if(document.getElementById('qty')) document.getElementById('qty').value = defaultQty;
            if(localStorage.getItem('grimoire_theme')) applyTheme(localStorage.getItem('grimoire_theme')); // Assumes applyTheme exists or remove if not using themes yet
            toggleVaultView(vaultViewMode); 
        }

        function showToast(m,t='info'){ 
            let c=document.getElementById('toast-container');
            if(!c){c=document.createElement('div');c.id='toast-container';document.body.appendChild(c)} 
            const el=document.createElement('div'); el.className=`toast ${t}`;
            el.innerHTML=`<span>${m}</span><span style="cursor:pointer;opacity:0.5;" onclick="this.parentElement.remove()">✕</span>`;
            c.appendChild(el);
            setTimeout(()=>{ el.classList.add('hiding'); el.addEventListener('transitionend',()=>el.remove()); }, 3000); 
        }

        function getCardImage(c) { 
            if(!c) return ''; 
            const setCode = c.set_code || c.set;
            const num = c.collector_number || c.num;
            if (!setCode || !num) return c.image_url || (c.image_uris && c.image_uris.normal) || (c.card_faces && c.card_faces[0].image_uris && c.card_faces[0].image_uris.normal) || '';
            const cacheKey = `img_cache_${setCode}_${num}`;
            const cachedUrl = localStorage.getItem(cacheKey);
            if (cachedUrl) return cachedUrl;
            let imageUrl = '';
            if(c.image_url) imageUrl = c.image_url; 
            else if(c.image_uris && c.image_uris.normal) imageUrl = c.image_uris.normal; 
            else if(c.card_faces && c.card_faces[0].image_uris && c.card_faces[0].image_uris.normal) imageUrl = c.card_faces[0].image_uris.normal; 
            if (imageUrl) localStorage.setItem(cacheKey, imageUrl);
            return imageUrl; 
        }

        // --- CHART FUNCTIONS (Moved UP to fix "clearCharts is not defined") ---
        function clearCharts() {
            if (typeChartInstance) { typeChartInstance.destroy(); typeChartInstance = null; }
            if (manaCurveInstance) { manaCurveInstance.destroy(); manaCurveInstance = null; }
            if (colorChartInstance) { colorChartInstance.destroy(); colorChartInstance = null; }
            document.getElementById('deck-charts').classList.add('hidden');
        }

        function renderTypeChart(typeData) {
            if (typeChartInstance) typeChartInstance.destroy();
            const ctx = document.getElementById('typeChart').getContext('2d');
            typeChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: Object.keys(typeData), datasets: [{ data: Object.values(typeData), backgroundColor: CHART_COLORS, borderWidth: 0 }] },
                options: { plugins: { legend: { position: 'right', labels: { color: '#a1a1aa' } } } }
            });
        }

        function renderManaCurve(cmcData) {
            if (manaCurveInstance) manaCurveInstance.destroy();
            const ctx = document.getElementById('manaCurve').getContext('2d');
            const labels = ['0','1','2','3','4','5','6','7+'];
            const data = labels.map((l, i) => cmcData[i] || 0); 
            // Simplified loop for brevity, robust version handles maxCMC dynamically
            manaCurveInstance = new Chart(ctx, {
                type: 'bar',
                data: { labels: labels, datasets: [{ label: 'Count', data: data, backgroundColor: '#a78bfa' }] },
                options: { plugins: { legend: { display: false } }, scales: { x: { ticks: { color: '#a1a1aa' } }, y: { ticks: { color: '#a1a1aa' } } } }
            });
        }

        function renderColorChart(colors) {
            if (colorChartInstance) colorChartInstance.destroy();
            const ctx = document.getElementById('colorChart').getContext('2d');
            const labels = ['White', 'Blue', 'Black', 'Red', 'Green', 'Colorless'];
            const data = [colors['W']||0, colors['U']||0, colors['B']||0, colors['R']||0, colors['G']||0, colors['C']||0];
            const bg = ['#f0f2c0', '#b3ceea', '#a69f9d', '#ea9f82', '#c4d3ca', '#d8d8d8'];
            colorChartInstance = new Chart(ctx, {
                type: 'polarArea',
                data: { labels: labels, datasets: [{ data: data, backgroundColor: bg, borderWidth: 0 }] },
                options: { plugins: { legend: { position: 'right', labels: { color: '#a1a1aa' } } }, scales: { r: { ticks: { display: false }, grid: { color: 'rgba(255,255,255,0.1)' } } } }
            });
        }

        function renderEditorChart(data) {
            const ctx = document.getElementById('editorManaChart').getContext('2d');
            if (editorChartInstance) editorChartInstance.destroy();
            editorChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { labels: ['0','1','2','3','4','5','6','7+'], datasets: [{ data: Object.values(data), backgroundColor: '#3b82f6', borderRadius: 2 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { ticks: { color: '#a1a1aa', font: { size: 9 } }, grid: { display: false } }, y: { display: false, grid: { display: false } } }, animation: { duration: 0 } }
            });
        }

        // --- AUTH ---
        function toggleResetMode(){ isResetMode=!isResetMode; const g=document.getElementById('password').parentElement; if(isResetMode){g.classList.add('hidden');document.getElementById('auth-btn').innerText="Send Recovery";document.getElementById('forgot-link').innerText="Back";}else{g.classList.remove('hidden');document.getElementById('auth-btn').innerText="Summon Session";document.getElementById('forgot-link').innerText="Forgot Password?";}}
        async function handleAuthAction(){if(isResetMode){const e=document.getElementById('email').value;const{error}=await sb.auth.resetPasswordForEmail(e,{redirectTo:window.location.href});if(error)showToast(error.message,"error");else showToast("Check email!","success")}else{const e=document.getElementById('email').value,p=document.getElementById('password').value;let{data,error}=await sb.auth.signInWithPassword({email:e,password:p});if(error){if(error.message.includes("Invalid login credentials")){showToast("Creating account...","info");const sup=await sb.auth.signUp({email:e,password:p});if(sup.error){showToast(sup.error.message,"error");}else{if(sup.data.session)finalizeLogin(sup.data.session);else showToast("Account created! Check email.","success");}}else{showToast(error.message,"error");}}else{finalizeLogin(data.session);}}}
        function finalizeLogin(s){ session=s; document.getElementById('auth-screen').classList.add('hidden'); document.getElementById('app').classList.remove('hidden'); document.getElementById('user-email').innerText=s.user.email; loadData(); loadPrefs(); loadProfile(); }
        async function handleLogout(){ await sb.auth.signOut(); window.location.reload(); }
        async function loadProfile() { const { data } = await sb.from('profiles').select('*').eq('id', session.user.id).single(); if (data) { if(data.username) document.getElementById('settings-username').value = data.username; if(data.avatar_url) document.getElementById('sidebar-avatar').src = data.avatar_url; } }
        async function saveProfile() { const username = document.getElementById('settings-username').value; const avatar = document.getElementById('sidebar-avatar').src; const { error } = await sb.from('profiles').upsert({ id: session.user.id, username, avatar_url: avatar, updated_at: new Date() }); if(error) showToast("Error saving profile", "error"); else showToast("Identity Updated!", "success"); }
        async function updatePassword() { const p = document.getElementById('new-password').value; if(!p) return; const { error } = await sb.auth.updateUser({ password: p }); if(error) showToast(error.message, "error"); else showToast("Password updated!", "success"); }

        // --- NAVIGATION ---
        function nav(v,i){ 
            document.querySelectorAll('.main > div').forEach(d=>d.classList.add('hidden')); 
            const view = document.getElementById('view-'+v);
            if(view) view.classList.remove('hidden'); // Safety check
            
            document.querySelectorAll('.nav-item').forEach(el=>el.classList.remove('active')); 
            document.querySelectorAll('.b-item').forEach(el=>el.classList.remove('active')); 
            
            if (i) {
                const bItem = document.querySelector(`.b-item[onclick="nav('${v}', '${i}')"]`);
                if(bItem) bItem.classList.add('active');
            } else {
                const nItem = document.querySelector(`.nav-item[onclick="nav('${v}', '${v}')"]`);
                if(nItem) nItem.classList.add('active');
            }

            if(v==='decks'){ 
                loadDecks(); 
            } else { 
                document.getElementById('deck-workspace').classList.add('hidden'); 
                document.getElementById('deck-library').classList.remove('hidden'); 
                showRitualEditor(false); // Can safely call now that clearCharts is defined above
            } 
            if(v==='collection') loadCollection(); 
            if(v==='oracle') loadOracle(); 
            if(v==='settings') renderTagManager();
            if(v==='add') renderQuickTags();
        }

        // --- DATA LOADING & ADDING ---
        async function loadData() { 
            const { data: cards, error } = await sb.from('cards').select('*').order('created_at', { ascending: false }); 
            if(error) return console.error(error); 
            cardsCache = cards; 
            vaultLookup = {};
            cardsCache.forEach(c => { 
                const key = `${c.name.toLowerCase().trim()}_${c.set_code || c.set}_${c.collector_number || c.num}`;
                vaultLookup[key] = (vaultLookup[key] || 0) + c.quantity;
            });
            // Stats calculation (simplified for brevity)
            let count=0, totalVal=0;
            cards.forEach(c => { if(c.quantity>0) { count+=c.quantity; totalVal+=(c.market_price_usd||0)*c.quantity; } });
            document.getElementById('stat-count').innerText = count;
            document.getElementById('stat-value').innerText = "$"+totalVal.toFixed(2);
            document.querySelectorAll('.stat-val').forEach(el => el.classList.remove('skeleton'));
            // Populate recent grid...
            const owned = cards.filter(c=>c.quantity>0).slice(0,5);
            document.getElementById('recent-grid').innerHTML = owned.map(c => `<div class="grid-card animate-in"><img src="${getCardImage(c)}" loading="lazy"><div class="overlay"><span>${c.name}</span></div></div>`).join('');
        }

        function debounceSearch(){ clearTimeout(searchTimer); searchTimer=setTimeout(fetchCardMeta,500); }
        async function fetchCardMeta(){ 
            const n=document.getElementById('search').value.trim(); 
            if(n.length<3) return;
            document.getElementById('search-status').innerText = "Consulting Scryfall...";
            try{ 
                const res = await fetch(`https://api.scryfall.com/cards/search?q=${encodeURIComponent(n)}&unique=prints`); 
                const d = await res.json(); 
                if(!d.data) { allVersions=[]; document.getElementById('search-status').innerText = "No cards found."; return; }
                allVersions = d.data;
                document.getElementById('search-status').innerText = `${allVersions.length} versions found.`;
                const s=document.getElementById('versionSelect'); s.innerHTML=''; 
                allVersions.forEach((v,i)=>{ const o=document.createElement('option'); o.value=i; o.text=`${v.set_name} - $${v.prices.usd||'N/A'}`; s.appendChild(o); }); 
                updateSelectedVersion(); 
            } catch(e){ document.getElementById('search-status').innerText = "Network Error."; } 
        }

        function updateSelectedVersion(){ 
            const index = document.getElementById('versionSelect').value;
            const v = allVersions[index];
            if(!v) return;
            const price = parseFloat(v.prices.usd||0);
            document.getElementById('set').value = v.set.toUpperCase(); 
            document.getElementById('num').value = v.collector_number; 
            document.getElementById('marketPrice').innerHTML = `$${price.toFixed(2)}`; 
            document.getElementById('preview').src = getCardImage(v); 
            document.getElementById('preview').style.display = 'block'; 
            document.getElementById('preview-text').style.display = 'none'; 
            
            tempCardData = { 
                name: v.name, set: v.set.toUpperCase(), num: v.collector_number, img: getCardImage(v), 
                market_price: price, type_line: v.type_line, rarity: v.rarity, colors: v.colors||[], cmc: v.cmc||0 
            }; 
            document.getElementById('qty').readOnly = false;
        }

        async function addCard(isWishlist = false) { 
            const btn = document.querySelector(`button[onclick="addCard(${isWishlist})"]`);
            if(!tempCardData) return showToast("Select a card first", "error"); 
            setLoading(btn, true);
            try {
                const qty = isWishlist ? 0 : (parseInt(document.getElementById('qty').value)||1);
                const cost = document.getElementById('cost').value ? parseFloat(document.getElementById('cost').value) : null;
                const tags = document.getElementById('add-tags').value.split(',').filter(t=>t.trim());
                
                const { error } = await sb.from('cards').insert({ 
                    user_id: session.user.id, name: tempCardData.name, set_code: tempCardData.set, collector_number: tempCardData.num, 
                    image_url: tempCardData.img, buy_price: cost, quantity: qty, market_price_usd: tempCardData.market_price, 
                    tags: tags, last_price_update: new Date().toISOString(), type_line: tempCardData.type_line, rarity: tempCardData.rarity, 
                    colors: tempCardData.colors, cmc: tempCardData.cmc 
                });
                
                if(!error) { 
                    showToast("Card Added!", "success"); 
                    document.getElementById('search').value=""; 
                    tempCardData=null; 
                    loadData(); 
                } else showToast(error.message, "error");
            } catch(e) { showToast("Error adding card", "error"); } 
            finally { setLoading(btn, false); }
        }

        // --- DECK MANAGEMENT ---
        async function loadDecks() {
            document.getElementById('deck-workspace').classList.add('hidden');
            document.getElementById('deck-library').classList.remove('hidden');
            const { data } = await sb.from('decks').select('*').order('updated_at', { ascending: false });
            const grid = document.getElementById('deck-grid-container');
            window.myDecks = data || [];
            let html = `<div class="deck-card new-deck-card" onclick="showRitualEditor()"><span style="font-size:30px;">➕</span><span>New Deck</span></div>`;
            if (data) html += data.map(d => `<div class="deck-card animate-in" onclick="viewRitualDetails('${d.id}')" style="background-image:url('${d.cover_url}')"><div class="deck-card-content"><h4>${d.name}</h4><div class="deck-card-meta"><span>${d.card_count} Cards</span><span class="format-badge">${d.format}</span></div></div></div>`).join('');
            grid.innerHTML = html;
        }

        // Fix for "allMatchedCards" error: Define variables at top of function
        async function validateDeck() {
            let allMatchedCards = []; // FIXED: Initialized here
            let allUnmatched = [];    // FIXED: Initialized here
            
            const name = document.getElementById('deckName').value;
            const commander = document.getElementById('deckCommander').value; 
            const format = document.getElementById('deckFormat').value; 
            const main = document.getElementById('deckMain').value;
            const side = document.getElementById('deckSide').value;
            const listText = main + '\n' + side;
            const btn = document.getElementById('validateDeckBtn');
            
            if (!listText.trim() && !commander.trim()) return showToast("Decklist is empty.", "error");

            // UI Switch
            document.getElementById('deck-library').classList.add('hidden');
            document.getElementById('deck-workspace').classList.remove('hidden');
            document.getElementById('editor-mode').classList.add('hidden');
            document.getElementById('detail-mode').classList.remove('hidden');
            document.getElementById('detail-deck-name').innerText = name || "New Decklist";
            
            analyzeOwnership(listText); // Fast local check first

            if (window.currentDeckStructuredList && window.currentDeckStructuredList.length > 0) {
                 // Cached path
                 processDeckData(window.currentDeckStructuredList, commander, format, document.getElementById('detail-analysis-results'), [], []);
                 return;
            }

            // API Path
            const { cards: parsedCards } = parseDeckList(listText);
            const cardsToResolve = [...parsedCards];
            if (commander.trim()) cardsToResolve.push({ qty: 1, name: commander });

            if (cardsToResolve.length === 0) return showToast("No cards to resolve.", "error");

            if (btn) { btn.innerText = "Resolving..."; btn.disabled = true; }

            try {
                // Chunking logic (simplified for brevity)
                const identifiers = cardsToResolve.map(c => ({ name: c.name }));
                const res = await fetch('https://api.scryfall.com/cards/collection', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ identifiers }) });
                const data = await res.json();
                
                if (data.data) allMatchedCards = data.data;
                if (data.not_found) allUnmatched = data.not_found;
                
                processDeckData(allMatchedCards, commander, format, document.getElementById('detail-analysis-results'), parsedCards, allUnmatched);

            } catch (e) { showToast("Validation Error", "error"); } 
            finally { if(btn) { btn.innerText = "✅ Validate"; btn.disabled = false; } }
        }

        function processDeckData(matchedCards, commander, format, resultsEl, parsedCards, allUnmatched) {
            let structuredDeck = [];
            let totalDeckPrice = 0;
            let typeAgg = {}, cmcAgg = {};
            window.currentDeckStats = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };
            currentDeckCache = []; // Populate cache for drag & drop

            matchedCards.forEach(card => {
                // Find original qty requested
                let qty = 1;
                const req = parsedCards.find(p => p.name.toLowerCase() === card.name.toLowerCase());
                if (req) qty = req.qty;
                
                // Add to Structured List
                const price = parseFloat(card.prices.usd||0);
                structuredDeck.push({
                    name: card.name, qty: qty, set: card.set, num: card.collector_number,
                    img: getCardImage(card), type: card.type_line, cmc: card.cmc, 
                    price: price, identity: card.color_identity
                });
                
                currentDeckCache.push({ ...card, quantity: qty }); // For battlefield
                totalDeckPrice += (price * qty);

                // Stats
                const type = card.type_line.split('—')[0].trim();
                typeAgg[type] = (typeAgg[type]||0) + qty;
                if(!type.includes('Land')) {
                    const cmc = Math.floor(card.cmc||0);
                    cmcAgg[cmc] = (cmcAgg[cmc]||0) + qty;
                }
                // Mana pips (simplified)
                if(card.mana_cost) {
                    window.currentDeckStats['W'] += (card.mana_cost.match(/{W}/g)||[]).length * qty;
                    window.currentDeckStats['U'] += (card.mana_cost.match(/{U}/g)||[]).length * qty;
                    window.currentDeckStats['B'] += (card.mana_cost.match(/{B}/g)||[]).length * qty;
                    window.currentDeckStats['R'] += (card.mana_cost.match(/{R}/g)||[]).length * qty;
                    window.currentDeckStats['G'] += (card.mana_cost.match(/{G}/g)||[]).length * qty;
                }
            });

            window.currentDeckStructuredList = structuredDeck;
            document.getElementById('detail-deck-price').innerText = `$${totalDeckPrice.toFixed(2)}`;
            
            // Render
            clearCharts();
            document.getElementById('deck-charts').classList.remove('hidden');
            renderTypeChart(typeAgg);
            renderManaCurve(cmcAgg);
            renderColorChart(window.currentDeckStats);
            analyzeDeckStructure(currentDeckCache); // V9.0 Advisor
            analyzeOwnership(document.getElementById('deckMain').value); // Re-run ownership with prices
        }

        // --- V9.0 & V9.1 HELPERS ---
        function analyzeDeckStructure(deckList) {
            const stats = { lands:{count:0,target:36}, ramp:{count:0,target:10}, draw:{count:0,target:10}, removal:{count:0,target:10}, wipes:{count:0,target:3} };
            deckList.forEach(c => {
                const txt = (c.oracle_text||"").toLowerCase(), type=(c.type_line||"").toLowerCase(), qty=c.quantity||1;
                if(type.includes('land')) { stats.lands.count+=qty; return; }
                if((txt.includes('add ')||txt.includes('search your library')) && (txt.includes('mana')||txt.includes('land'))) stats.ramp.count+=qty;
                if(txt.includes('draw') && txt.includes('card')) stats.draw.count+=qty;
                if((txt.includes('destroy')||txt.includes('exile')) && txt.includes('target')) stats.removal.count+=qty;
                if((txt.includes('destroy')||txt.includes('exile')||txt.includes('damage')) && (txt.includes('all')||txt.includes('each'))) stats.wipes.count+=qty;
            });
            renderAdvisor(stats);
        }

        function renderAdvisor(stats) {
            let html='';
            for(const [k,d] of Object.entries(stats)) {
                const pct = Math.min(100, (d.count/d.target)*100);
                let color = 'var(--red)';
                if(pct > 80 && pct < 120) color='var(--green)'; else if(pct > 50) color='var(--yellow)';
                html+=`<div class="mb-5"><div class="flex-between text-sub"><span style="text-transform:capitalize;">${k}</span><span>${d.count}/${d.target}</span></div><div class="progress-bg"><div class="progress-fill" style="width:${pct}%; background:${color};"></div></div></div>`;
            }
            document.getElementById('advisor-grid').innerHTML = html;
        }

        // Live Editor Listeners (V9.1)
        function initEditorListeners() {
            const h = () => { clearTimeout(searchTimer); searchTimer=setTimeout(updateLiveEditorStats, 500); };
            document.getElementById('deckMain').addEventListener('input', h);
        }
        function updateLiveEditorStats() {
            const txt = document.getElementById('deckMain').value;
            const lines = txt.split('\n');
            const data = {0:0,1:0,2:0,3:0,4:0,5:0,6:0,7:0};
            let total=0;
            lines.forEach(l => {
                const m = l.match(/^(\d+)\s+(.+)/);
                if(m) {
                    const q=parseInt(m[1]), n=m[2].trim().toLowerCase();
                    total+=q;
                    const c = cardsCache.find(x=>x.name.toLowerCase()===n);
                    if(c && c.cmc !== undefined) {
                        let bucket = Math.floor(c.cmc); if(bucket>7) bucket=7;
                        data[bucket]+=q;
                    }
                }
            });
            document.getElementById('editor-card-count').innerText = `${total} Cards`;
            renderEditorChart(data);
        }

        function showRitualEditor() {
            document.getElementById('deck-library').classList.add('hidden');
            document.getElementById('deck-workspace').classList.remove('hidden');
            document.getElementById('detail-mode').classList.add('hidden');
            document.getElementById('editor-mode').classList.remove('hidden');
            clearCharts();
            initEditorListeners();
            updateLiveEditorStats();
        }

        // --- LAND CALCULATOR ---
        // V9.3: Fix for openLandCalculator not defined (Added definition here)
        function openLandCalculator() {
            document.getElementById('land-modal').classList.remove('hidden');
            recalcLands();
        }
        function recalcLands() {
            const target = parseInt(document.getElementById('target-land-count').value) || 36;
            if (!window.currentDeckStats) return;
            const s = window.currentDeckStats;
            const total = s.W+s.U+s.B+s.R+s.G;
            if(total===0) { document.getElementById('land-results').innerHTML="No symbols found."; return; }
            let html='';
            suggestedLands=[];
            const types=[{n:'Plains',c:'pip-w',v:s.W},{n:'Island',c:'pip-u',v:s.U},{n:'Swamp',c:'pip-b',v:s.B},{n:'Mountain',c:'pip-r',v:s.R},{n:'Forest',c:'pip-g',v:s.G}];
            types.forEach(t=>{
                if(t.v>0) {
                    const count = Math.round((t.v/total)*target);
                    if(count>0) {
                        suggestedLands.push({name:t.n, qty:count});
                        html+=`<div class="mana-row"><div><span class="mana-pip ${t.c}"></span> ${t.n}</div><div class="text-bold">${count}</div></div>`;
                    }
                }
            });
            document.getElementById('land-results').innerHTML=html;
        }
        function applyLands() {
            const box = document.getElementById('deckMain');
            let txt = box.value.trim();
            if(txt) txt+='\n';
            suggestedLands.forEach(l => txt+=`${l.qty} ${l.name}\n`);
            box.value=txt;
            document.getElementById('land-modal').classList.add('hidden');
            updateLiveEditorStats();
        }

        function parseDeckList(t){ const l=t.split('\n'); const cards=[]; let c=0; l.forEach(x=>{ const m=x.match(/^(\d+)\s+(.+)/); if(m){ const q=parseInt(m[1]); cards.push({qty:q, name:m[2].trim()}); c+=q; } }); return {totalCount:c, cards:cards}; }
        function viewRitualDetails(id) { currentViewedDeckId=id; document.getElementById('deck-library').classList.add('hidden'); document.getElementById('deck-workspace').classList.remove('hidden'); validateDeck(); } // Simplified view logic
        function analyzeOwnership(t) { document.getElementById('detail-decklist-viewer').innerText = t; } // Fallback display

        // --- INIT ---
        sb.auth.getSession().then(({ data: { session: s } }) => {
            if (s) {
                session = s;
                document.getElementById('auth-screen').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('user-email').innerText = s.user.email;
                loadData(); loadPrefs(); loadProfile();
            }
        });
    </script>
</body>
</html>
